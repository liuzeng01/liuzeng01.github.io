<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My Document on iNote</title>
    <link>https://liuzeng01.github.io/</link>
    <description>Recent content in My Document on iNote</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://liuzeng01.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>hugo语法</title>
      <link>https://liuzeng01.github.io/essay/july/hugo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/essay/july/hugo/</guid>
      <description>1. hugo 2. Ace Document   button The button shortcode allows you to add a button to the page. This button is a HTML anchor element and can thus be used to link to another page or website.
ButtonButtonButtonButtonButtonButtonButtonUsage Place the following shortcode on the page Copy{{&amp;lt; button style=&amp;#34;STYLE&amp;#34; link=&amp;#34;https://yourwebsite.com&amp;#34; &amp;gt;}} [content] {{&amp;lt; /button &amp;gt;}} Parameters style The style parameter is directly applied to the alert as a class in the format &amp;ldquo;btn-{STYLE}&amp;quot;.</description>
    </item>
    
    <item>
      <title>Json </title>
      <link>https://liuzeng01.github.io/programing/go/daily/json/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/daily/json/</guid>
      <description>Json   func Marshal(v interface{}) ([]byte, error) // json编码
  func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error) // json编码带缩进
  func Unmarshal(data []byte, v interface{}) error // json解码
  package main import ( &amp;#34;fmt&amp;#34; // &amp;#34;reflect&amp;#34;  &amp;#34;encoding/json&amp;#34; ) type User struct{ // Name string `json:&amp;#34;-,&amp;#34;` // 这个导出才是 {&amp;#34;-&amp;#34;:&amp;#34;张三&amp;#34;,&amp;#34;age&amp;#34;:20}  // Name string `json:&amp;#34;-&amp;#34;` // always omitted  // Name string `json:&amp;#34;,omitempty&amp;#34;` // 如果为零值导出为空. 然而不想重命名.</description>
    </item>
    
    <item>
      <title>Sort</title>
      <link>https://liuzeng01.github.io/programing/go/daily/sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/daily/sort/</guid>
      <description>实现Go提供的sort接口，来进行自定义排序  只需要实现下列三个接口，就可以进行排序
 package sort type Interface interface { Len() int // 获取元素数量  Less(i, j int) bool // i，j是序列元素的指数。  Swap(i, j int) // 交换元素 } 自己模拟了一个最简单的示例
package mainimport (&amp;quot;fmt&amp;quot;&amp;quot;sort&amp;quot;)func main() {var mysort MySortvar a SortTypea.id = 5a.Name = &amp;quot;a&amp;quot;var b SortTypeb.id = 51b.Name = &amp;quot;b&amp;quot;var c SortTypec.id = 6c.Name = &amp;quot;c&amp;quot;var d SortTyped.</description>
    </item>
    
    <item>
      <title>SRE介绍</title>
      <link>https://liuzeng01.github.io/booknote/sre/sre%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/booknote/sre/sre%E4%BB%8B%E7%BB%8D/</guid>
      <description> SRESRE是指Site Reliability Engineer (网站可靠性工程师)。他是软件工程师和系统管理员的结合，一个SRE工程师基本上需要掌握很多知识：算法，数据结构，编程能力，网络编程，分布式系统，可扩展架构，故障排除。SRE都干些什么？ SRE不是做底层硬件维护，而是负责各种服务的性能和稳定性。远离底层硬件，更多靠近软件基础架构层面，帮助企业客户打造强大的软件基础构架。 Back</description>
    </item>
    
    <item>
      <title>SSH</title>
      <link>https://liuzeng01.github.io/programing/go/daily/ssh/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/daily/ssh/</guid>
      <description>利用Go语言提供的ssh包实现一个ssh工具 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net&amp;#34; &amp;#34;os&amp;#34; &amp;#34;time&amp;#34; &amp;#34;golang.org/x/crypto/ssh&amp;#34; ) func main() { session, err := connect(&amp;#34;root&amp;#34;, &amp;#34;abc@123A&amp;#34;, &amp;#34;10.45.11.115&amp;#34;, 22) if err != nil { log.Fatal(err) } defer session.Close() fmt.Printf(&amp;#34;----&amp;gt;&amp;#34;) session.Stdout = os.Stdout session.Stderr = os.Stderr session.Stdin = os.Stdin session.Run(&amp;#34;sh&amp;#34;) } func connect(user, password, host string, port int) (*ssh.Session, error) { var ( addr string clientConfig *ssh.ClientConfig client *ssh.Client session *ssh.Session err error ) clientConfig = &amp;amp;ssh.ClientConfig{ User: user, Auth: []ssh.</description>
    </item>
    
    <item>
      <title>文件操作</title>
      <link>https://liuzeng01.github.io/programing/go/daily/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/daily/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</guid>
      <description>1.打开关闭文件 file open/close
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) func main() { // 只读方式打开当前目录下的main.go文件 	file, err := os.Open(&amp;#34;./main.go&amp;#34;) if err != nil { fmt.Println(&amp;#34;open file failed!, err:&amp;#34;, err) return } // 关闭文件 	file.Close() } 2.文件读取 file read 它接收一个字节切片，返回读取的字节数和可能的具体错误，读到文件末尾时会返回0和io.EOF
func (f *File) Read(b []byte) (n int, err error) func main() { // 只读方式打开当前目录下的main.go文件 	file, err := os.Open(&amp;#34;./main.go&amp;#34;) if err != nil { fmt.Println(&amp;#34;open file failed!, err:&amp;#34;, err) return } defer file.</description>
    </item>
    
    <item>
      <title>routine</title>
      <link>https://liuzeng01.github.io/programing/go/github.com/x-mod/routine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/github.com/x-mod/routine/</guid>
      <description>github.com/x-mod/routine  为什么要写这么一个基础库呢？
  每段程序都是从 main 函数开始的，但是，却不会将整个程序的功能实现都放在 main 函数里。而是，通过层层功能的抽象与封装，最终，在 main 函数仅提供功能函数的入口。所以，当我们看很多大型程序时，其实，main 函数是非常简单的。
  但是，即使 main 函数越变越简单，有些必要的功能则是逃不掉的。例如程序启动参数、程序的信号处理，这些通常还是会放在 main 函数进行处理。
  除了以上 main 函数本身的处理以外，我发现将程序中的执行绪，也就是固定的 Go 协程的入口放在 main 函数中进行定义，可以帮助维护者更加快速的理解应用的逻辑实现。
 link 使用方法 import &amp;#34;github.com/x-mod/routine&amp;#34; //timeout timeout := routine.Timeout(time.Minute, exec) //retry retry := routine.Retry(3, exec) //repeat repeat := routine.Repeat(10, time.Second, exec) //concurrent concurrent := routine.Concurrent(4, exec) //schedule executor crontab := routine.Crontab(&amp;#34;* * * * *&amp;#34;, exec) //command command := routine.Command(&amp;#34;echo&amp;#34;, routine.ARG(&amp;#34;hello routine!</description>
    </item>
    
    <item>
      <title>hugo</title>
      <link>https://liuzeng01.github.io/programing/go/github.com/gohugoio/hugo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/github.com/gohugoio/hugo/</guid>
      <description>DescriptionHugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。 Hugo采用 Go 编程语言开发，Hugo 的设计目标是让创建网站重新变得有趣。Show More Hugo 是一个通用的网站框架。从技术上讲，Hugo 是一个静态站点生成器。与动态构建页面的系统不同，Hugo 在创建或更新内容时构建页面。由于网站的浏览频率远高于编辑频率，因此 Hugo 旨在为您的网站最终用户提供最佳的浏览体验，并为网站作者提供理想的写作体验。使用 Hugo 构建的网站非常快速和安全。Hugo 构建的网站可以托管在任何地方，包括 Netlify、Heroku、GoDaddy、DreamHost、GitHub Pages、GitLab Pages、Surge、Aerobatic、Firebase、Google Cloud Storage、Amazon S3、Rackspace、Azure, 和 CloudFront，并且与 CDN 更配。Hugo 网站在运行时不需要数据库或依赖于诸如 Ruby、Python 或 PHP 等昂贵的运行时环境。我们认为 Hugo 是一个理想的网站创建工具，具有几乎即时的构建时间，能够在网站修改时即刻重建。
1. Hugo 部署   二进制安装（推荐：简单、快速） 到 Hugo Releases 下载对应的操作系统版本的Hugo二进制文件（hugo或者hugo.exe）
  编译部署 熟悉Go语言的朋友可以试下这个方法，不过great wall的存在让依赖不太好下载。不过下载下之后可以自己进行魔改。geek们可以试下。
go get -u -v github.com/spf13/hugo
  开始建立hugo project hugo new site mydocs 建立好之后的目录结构为</description>
    </item>
    
    <item>
      <title>nutsdb</title>
      <link>https://liuzeng01.github.io/programing/go/github.com/xujiajun/nutsdb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/github.com/xujiajun/nutsdb/</guid>
      <description>DescriptionNutsDB是纯Go语言编写一个简单、高性能、内嵌型、持久化的key-value数据库。
NutsDB支持事务，从v0.2.0之后的版本开始支持ACID的特性，建议使用最新的release版本。v0.2.0之前的版本，保持高性能，没有作sync，但是具备高性能的写（本地测试，百万数据写入达40~50W+/s）。所有的操作都在事务中执行。NutsDB从v0.2.0版本开始支持多种数据结构，如列表(list)、集合(set)、有序集合(sorted set)。从0.4.0版本开始增加自定义配置读写方式、启动时候的文件载入方式、sync是否开启等
github.com/xujiajun/nutsdb  官方文档
1. 安装 go get -u github.com/xujiajun/nutsdb 2. 使用 开启数据库 package main import ( &amp;#34;log&amp;#34; &amp;#34;github.com/xujiajun/nutsdb&amp;#34; ) func main() { opt := nutsdb.DefaultOptions opt.Dir = &amp;#34;/tmp/nutsdb&amp;#34; //这边数据库会自动创建这个目录文件 	db, err := nutsdb.Open(opt) if err != nil { log.Fatal(err) } defer db.Close() ... } 这里的默认配置是
var DefaultOptions = Options{ EntryIdxMode: HintKeyValAndRAMIdxMode, //EntryIdxMode 代表索引entry的模式. EntryIdxMode 包括选项: HintKeyValAndRAMIdxMode 、HintKeyAndRAMIdxMode和 HintBPTSparseIdxMode。其中HintKeyValAndRAMIdxMode 代表纯内存索引模式（key和value都会被cache）。 HintKeyAndRAMIdxMode 代表内存+磁盘的索引模式（只有key被cache）。 HintBPTSparseIdxMode（v0.</description>
    </item>
    
  </channel>
</rss>