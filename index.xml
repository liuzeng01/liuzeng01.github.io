<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My Document on iNote</title>
    <link>https://liuzeng01.github.io/</link>
    <description>Recent content in My Document on iNote</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://liuzeng01.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>dockerfile基础命令</title>
      <link>https://liuzeng01.github.io/linux/docker/dockerfile/command/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/linux/docker/dockerfile/command/</guid>
      <description>dockerfile 基础命令 FROM 指定基础镜像 FROM nginx
RUN 执行命令 exec 格式: RUN [&amp;quot;可执行文件&amp;quot;, &amp;quot;参数1&amp;quot;, &amp;quot;参数2&amp;quot;]RUN apt-get updateRUN apt-get install -y gcc libc6-dev makeCOPY 复制文件 COPY [&amp;quot;&amp;lt;源路径1&amp;gt;&amp;quot;,... &amp;quot;&amp;lt;目标路径&amp;gt;&amp;quot;]COPY package.json /usr/src/app/ADD 更高级的复制文件 ADD [&amp;quot;&amp;lt;源路径1&amp;gt;&amp;quot;,... &amp;quot;&amp;lt;目标路径&amp;gt;&amp;quot;]源路径可以使是url,如果是压缩包,自动解压缩,不推荐使用
FROM scratchADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gzCMD 容器启动命令 shell 格式: CMD &amp;lt;命令&amp;gt;exec 格式: CMD [&amp;quot;可执行文件&amp;quot;, &amp;quot;参数1&amp;quot;, &amp;quot;参数2&amp;quot;...]在指定了 ENTRYPOINT 指令后，用 CMD 指 定具体的参数
CMD [ &amp;quot;sh&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;echo $HOME&amp;quot; ]#CMD echo $HOMEENTRYPOINT 入口点 shell 格式: ENTRYPOINT &amp;lt;命令&amp;gt;exec 格式: ENTRYPOINT [&amp;quot;可执行文件&amp;quot;, &amp;quot;参数1&amp;quot;, &amp;quot;参数2&amp;quot;.</description>
    </item>
    
    <item>
      <title>HTTPS</title>
      <link>https://liuzeng01.github.io/essay/august/https/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/essay/august/https/</guid>
      <description>1. 加密的大致种类： 1、不可逆加密。比如 MD5、SHA、HMAC 典型用途：
密码总不能明文存到数据库吧，所以一般加密存起来，只要用户的输入经过同样的加密算法 对比一下就知道密码是否正确了，所以没必要可逆。 2、可逆加密。
对称加密。比如：AES、DES、3DES、IDEA、RC4、RC5、RC6 典型用途：
用同一个密码加密和解密，太常见了，我用密码加密文件发给你，你只能用我的密码才能解开。 非对称加密（就是公私钥）。比如：RSA、DSA、ECC
典型用途： 加密（保证数据安全性）使用公钥加密，需使用私钥解密。 认证（用于身份判断）使用私钥签名，需使用公钥验证签名。 2. 如何加密 用不可逆加密可行吗？ 首先不可逆加密的是不是可以直接排除了，不知道为啥的，可以想一想自己的目的是什么哈。
用对称加密可行吗？ 如果通信双方都各自持有同一个密钥，且没有别人知道，这两方的通信安全当然是可以被保证的,然而最大的问题就是这个密钥怎么让传输的双方知晓，同时不被别人知道,想一想：是不是不管怎么传，中间都有可能被截获，密钥都被截获了，其他的安全是不是也就无从谈起了。看来纯粹的对称加密不能解决http的安全问题。
用非对称加密（rsa）可行吗？ 试想一下：如果服务器生成公私钥，然后把公钥明文给客户端（有问题，下面说），那客户端以后传数据用公钥加密，服务端用私钥解密就行了，这貌似能保证浏览器到服务端的通道是安全的，那服务端到浏览器的通道如何保证安全呢？
那既然一对公私钥能保证，那如果浏览器本身也生成一对公私钥匙，然后把公钥明文发给服务端，抛开明文传递公钥的问题，那以后是不是可以安全通信了，的确可以！但https本身却不是这样做的，最主要的原因是非对称加密非常耗时，特别是加密解密一些较大数据的时候有些力不从心，当然还有其他原因。既然非对称加密非常耗时，那只能再考虑对称加密了。
用非对称加密 + 对称加密可行吗？ 上面提到浏览器拥有服务器的公钥，那浏览器生成一个密钥，用服务器的公钥加密传给服务端，然后服务端和浏览器以后拿这个密钥以对称加密的方式通信不就好了！完美！ 所以接下来说一下上面遗留的一个问题：服务端的公钥是明文传过去的，有可能导致什么问题呢？ 如果服务端在把明文公钥传递给浏览器的时候，被黑客截获下来，然后把数据包中的公钥替换成自己伪造的公钥（当然他自己有自己的私钥），浏览器本身是不知道公钥真假的，所以浏览器还是傻傻的按照之前的步骤，生成对称密钥，然后用假的公钥加密传递给服务端，这个时候，黑客截获到报文，然后用自己的私钥解密，拿到其中的对称密钥，然后再传给服务端，就这样神不知鬼不觉的，对称密钥被黑客截取，那以后的通信其实就是也就全都暴露给黑客了。
上面的流程到底哪里存在问题，以致使黑客可以任意冒充服务端的公钥！ 其实根本原因就是浏览器无法确认自己收到的公钥是不是网站自己的。
如何保证浏览器收到的公钥一定是该网站的公钥 现实生活中，如果想证明某身份证号一定是小明的，怎么办？看身份证。这里国家机构起到了“公信”的作用，身份证是由它颁发的，它本身的权威可以对一个人的身份信息作出证明。互联网中能不能搞这么个公信机构呢？给网站颁发一个“身份证”？当然可以，这就是平时经常说的数字证书。
什么是数字证书?证书都包含什么? 身份证之所以可信，是因为背后是国家，那数字证书如何才可信呢？这个时候找CA（Certificate Authority）机构。办身份证需要填写自己的各种信息，去CA机构申请证书需要什么呢？至少应该有以下几项吧：
1、网站域名 2、证书持有者 3、证书有效期 4、证书颁发机构 5、服务器公钥（最主要） 6、接下来要说的签名时用的hash算法那证书如何安全的送达给浏览器，如何防止被篡改呢？给证书盖个章（防伪标记）不就好了？这就又引出另外一个概念：数字签名。 什么是数字签名？签名的过程是什么 签名的过程其实也很简单：
1、CA机构拥有非对称加密的私钥和公钥。2、CA对证书明文信息进行hash。3、对hash后的值用私钥加密，得到数字签名。所以呢，总结一下：CA机构颁发的证书包含（证书内容的明文+签名）。 浏览器收到服务下发的证书之后，拿到证书明文和签名，怎么验证是否篡改了呢？ 大家知道，私钥签名，公钥验签。证书里面的签名是CA机构用私钥签名的，所以我只要用CA机构的公钥验证一下签名不就好了，怎么验证呢？ 还记得证书里面的明文包含什么吧，不记得的话看看上面的内容。
1、拿到证书里面明文的hash算法并对明文内容进行hash运算，得到A 。2、用CA的公钥解密签名得到B 。3、比较A 和 B，如果相等，说明没有被篡改，否则浏览器提示证书不可信。有没有发现一个问题？CA的公钥从哪里获取呢？
 这个简单，CA权威机构本来也没多少个，所以，浏览器内部都内置了各大CA机构的公钥信息。 简单总结一下： 如果证书被篡改，浏览器就提示不可信，终止通信，如果验证通过，说明公钥没问题，一定没被篡改。  公钥没被篡改，那浏览器生成的对称加密用的密钥用公钥加密发送给服务端，也只有服务端的私钥能解开，所以保证了 对称密钥不可能被截获，对称密钥没被截获，那双方的通信就一定是安全的。</description>
    </item>
    
    <item>
      <title>hugo语法</title>
      <link>https://liuzeng01.github.io/essay/july/hugo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/essay/july/hugo/</guid>
      <description>1. hugo MarkDown : Insert Picture And Design the Dimensions
&amp;lt;img src=&amp;#34;../../../image/zsmart/pcrf/nat1.jpg&amp;#34; width = &amp;#34;640&amp;#34; alt=&amp;#34;NAT1&amp;#34; align=center /&amp;gt; &amp;lt;img src=&amp;#34;../../../image/zsmart/pcrf/nat2.jpg&amp;#34; width = &amp;#34;640&amp;#34; alt=&amp;#34;NAT2&amp;#34; align=center /&amp;gt; 2. Ace Document   button The button shortcode allows you to add a button to the page. This button is a HTML anchor element and can thus be used to link to another page or website.
ButtonButtonButtonButtonButtonButtonButtonUsage Place the following shortcode on the page Copy{{&amp;lt; button style=&amp;#34;STYLE&amp;#34; link=&amp;#34;https://yourwebsite.</description>
    </item>
    
    <item>
      <title>Json </title>
      <link>https://liuzeng01.github.io/programing/go/note/july/json/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/note/july/json/</guid>
      <description>Json   func Marshal(v interface{}) ([]byte, error) // json编码
  func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error) // json编码带缩进
  func Unmarshal(data []byte, v interface{}) error // json解码
  package main import ( &amp;#34;fmt&amp;#34; // &amp;#34;reflect&amp;#34;  &amp;#34;encoding/json&amp;#34; ) type User struct{ // Name string `json:&amp;#34;-,&amp;#34;` // 这个导出才是 {&amp;#34;-&amp;#34;:&amp;#34;张三&amp;#34;,&amp;#34;age&amp;#34;:20}  // Name string `json:&amp;#34;-&amp;#34;` // always omitted  // Name string `json:&amp;#34;,omitempty&amp;#34;` // 如果为零值导出为空. 然而不想重命名.</description>
    </item>
    
    <item>
      <title>Node JS</title>
      <link>https://liuzeng01.github.io/programing/javascript/august/nodejs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/javascript/august/nodejs/</guid>
      <description> 1. 升级nodejs的步骤 sudo npm cache clean -f # 清除Node缓存 sudo npm install n -g # 安装node版本管理工具 n sudo n stable （安装node最新版本） # 安装最新版本 sudo n 8.9.4 （安装node指定版本8.9.4） # 安装指定版本  Back</description>
    </item>
    
    <item>
      <title>Shell 范例 1 </title>
      <link>https://liuzeng01.github.io/linux/shell/shellexample/basic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/linux/shell/shellexample/basic/</guid>
      <description>1. 数值操作 # 赋值，递增 [root@master week1]# i=1 [root@master week1]# let i++ [root@master week1]# echo $i 2 [root@master week1]# [root@master week1]# ((i++)) [root@master week1]# echo $i 3 ## 运算 [root@master week1]# expr $i * 5 15 ## 求幂 [root@master week1]# let $i=2**2 4 ## 进制转换 obase:目标进制 ，ibase：当前进制；转换数值 [root@master ~]# echo &amp;#34;obase=10;ibase=8;11&amp;#34;| bc -l 9 ## 产生一系列数值 [root@master ~]# seq 1 10 1 2 3 4 5 6 7 8 9 10 [root@master ~]# seq 1 2 10 1 3 5 7 9 2.</description>
    </item>
    
    <item>
      <title>Sort</title>
      <link>https://liuzeng01.github.io/programing/go/note/july/sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/note/july/sort/</guid>
      <description>实现Go提供的sort接口，来进行自定义排序  只需要实现下列三个接口，就可以进行排序
 package sort type Interface interface { Len() int // 获取元素数量  Less(i, j int) bool // i，j是序列元素的指数。  Swap(i, j int) // 交换元素 } 自己模拟了一个最简单的示例
package mainimport (&amp;quot;fmt&amp;quot;&amp;quot;sort&amp;quot;)func main() {var mysort MySortvar a SortTypea.id = 5a.Name = &amp;quot;a&amp;quot;var b SortTypeb.id = 51b.Name = &amp;quot;b&amp;quot;var c SortTypec.id = 6c.Name = &amp;quot;c&amp;quot;var d SortTyped.</description>
    </item>
    
    <item>
      <title>SRE介绍</title>
      <link>https://liuzeng01.github.io/booknote/sre/sre%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/booknote/sre/sre%E4%BB%8B%E7%BB%8D/</guid>
      <description> SRESRE是指Site Reliability Engineer (网站可靠性工程师)。他是软件工程师和系统管理员的结合，一个SRE工程师基本上需要掌握很多知识：算法，数据结构，编程能力，网络编程，分布式系统，可扩展架构，故障排除。SRE都干些什么？ SRE不是做底层硬件维护，而是负责各种服务的性能和稳定性。远离底层硬件，更多靠近软件基础架构层面，帮助企业客户打造强大的软件基础构架。 Back</description>
    </item>
    
    <item>
      <title>SSH</title>
      <link>https://liuzeng01.github.io/programing/go/note/july/ssh/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/note/july/ssh/</guid>
      <description>利用Go语言提供的ssh包实现一个ssh工具 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net&amp;#34; &amp;#34;os&amp;#34; &amp;#34;time&amp;#34; &amp;#34;golang.org/x/crypto/ssh&amp;#34; ) func main() { session, err := connect(&amp;#34;root&amp;#34;, &amp;#34;abc@123A&amp;#34;, &amp;#34;10.45.11.115&amp;#34;, 22) if err != nil { log.Fatal(err) } defer session.Close() fmt.Printf(&amp;#34;----&amp;gt;&amp;#34;) session.Stdout = os.Stdout session.Stderr = os.Stderr session.Stdin = os.Stdin session.Run(&amp;#34;sh&amp;#34;) } func connect(user, password, host string, port int) (*ssh.Session, error) { var ( addr string clientConfig *ssh.ClientConfig client *ssh.Client session *ssh.Session err error ) clientConfig = &amp;amp;ssh.ClientConfig{ User: user, Auth: []ssh.</description>
    </item>
    
    <item>
      <title>viper</title>
      <link>https://liuzeng01.github.io/programing/go/github.com/spf13/viper/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/github.com/spf13/viper/</guid>
      <description>1. 介绍  Viper是Go应用程序的完整配置解决方案，包括12-Factor应用程序。它旨在在应用程序中工作，并可以处理所有类型的配置需求和格式。它支持：
 设置默认值从JSON，TOML，YAML，HCL和Java属性配置文件中读取实时观看和重新读取配置文件（可选）从环境变量中读取从远程配置系统（etcd或Consul）读取，并观察变化从命令行标志读取从缓冲区读取设置显式值 Viper可以被认为是所有应用程序配置需求的注册表。
在构建现代应用程序时，您不必担心配置文件格式; 你可以专注于构建出色的软件。 Viper 可以做如下工作：
 加载并解析JSON、TOML、YAML、HCL 或 Java properties 格式的配置文件可以为各种配置项设置默认值可以在命令行中指定配置项来覆盖配置值提供了别名系统，可以不破坏现有代码来实现参数重命名可以很容易地分辨出用户提供的命令行参数或配置文件与默认相同的区别 Viper读取配置信息的优先级顺序，从高到低，如下：
 显式调用Set函数命令行参数环境变量配置文件key/value 存储系统默认值 Viper 的配置项的key不区分大小写。
2. 使用示例  1. 配置文件示例 internal.toml,配置数据库的连接信息 [DataBase] DBType = &amp;#34;mysql&amp;#34; Host = &amp;#34;127.0.0.1:3306&amp;#34; Username = &amp;#34;golang&amp;#34; Password = &amp;#34;golang&amp;#34; Charset = &amp;#34;utf8&amp;#34; 2. 声明数据库连接对象 type DBModel struct { Engine *sql.</description>
    </item>
    
    <item>
      <title>动态规划</title>
      <link>https://liuzeng01.github.io/booknote/algorithm/dynamic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/booknote/algorithm/dynamic/</guid>
      <description> 1.实例说明什么是动态规划 计算1到10的和 计算过程：1+2+3+4+5+6+7+8+9+10，得55
上述如果口算，最快也要前后凑整10的相加，就是需要计算所有的值，才能得出结果。这时候，如果再加一个11，你肯定会脱口而出，得66，为什么直接能说出来呢，因为你记住了前面所求的得和，这一次得计算不需要关心前面这个55怎么来得，只关注这一步即可。
引出定义：（有点难理解）在现实生活中，有一类活动的过程，由于它的特殊性，可将过程分成若干个互相联系的阶段，在它的每一阶段都需要作出决策，从而使整个过程达到最好的活动效果。因此各个阶段决策的选取不能任意确定，它依赖于当前面临的状态，又影响以后的发展。当各个阶段决策确定后，就组成一个决策序列，因而也就确定了整个过程的一条活动路线．这种把一个问题看作是一个前后关联具有链状结构的多阶段过程就称为多阶段决策过程，这种问题称为多阶段决策问题。在多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化的过程为动态规划方法。
优化理解：动态规划是把一个大问题拆解成一堆小问题，这个本身没什么问题，但是核心不是能拆分，而是取决于该问题拆分出的小问题是否能被特定的规律重复利用。  2. 实际问题解决例子：路径最小值问题 给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点
例如，给定三角形： [ [2], [3,4], [6,5,7], [4,1,8,3] ] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
过程解析：自上而下计算时，只要每一步都记录路径上最小的值即可，因为路径上只能访问相邻的两个点，所以比较两个相邻点和本点数据的和，保存较小的一个值即可。不断向下类推，最后一组数据中最小的值就是i最小路径。
func minimumTotal(triangle [][]int) int { for i, v := range triangle { if i == 0 {//第一层没有上一级，不用计算  continue } for idx, val := range v { if idx == len(v)-1 {//最后一个值,他的上一级比他小一位数,所以相邻点只有一个直接赋值  triangle[i][idx] = val + triangle[i-1][idx-1] continue } if idx == 0 {//第一位，相邻点也只有一个，直接赋值  triangle[i][idx] = val + triangle[i-1][idx] continue } if val+triangle[i-1][idx] &amp;gt; val+triangle[i-1][idx-1] {// 比较相邻点较小值，并记录  triangle[i][idx] = val + triangle[i-1][idx-1]// 不需要原来的值,直接赋值保存即可,因为只关心路径结果即可  } else { triangle[i][idx] = val + triangle[i-1][idx] } } } min := triangle[len(triangle)-1][0] for _, v := range triangle[len(triangle)-1] {//最后一组中最小值就是路径最小  if v &amp;lt; min { min = v } } return min }  Back</description>
    </item>
    
    <item>
      <title>文件操作</title>
      <link>https://liuzeng01.github.io/programing/go/note/july/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/note/july/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</guid>
      <description>1.打开关闭文件 file open/close
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) func main() { // 只读方式打开当前目录下的main.go文件 	file, err := os.Open(&amp;#34;./main.go&amp;#34;) if err != nil { fmt.Println(&amp;#34;open file failed!, err:&amp;#34;, err) return } // 关闭文件 	file.Close() } 2.文件读取 file read 它接收一个字节切片，返回读取的字节数和可能的具体错误，读到文件末尾时会返回0和io.EOF
func (f *File) Read(b []byte) (n int, err error) func main() { // 只读方式打开当前目录下的main.go文件 	file, err := os.Open(&amp;#34;./main.go&amp;#34;) if err != nil { fmt.Println(&amp;#34;open file failed!, err:&amp;#34;, err) return } defer file.</description>
    </item>
    
    <item>
      <title>Golang of linux </title>
      <link>https://liuzeng01.github.io/linux/kubernetes/deploy/golang/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/linux/kubernetes/deploy/golang/</guid>
      <description> 1. 安装包 # 安装bai mercurial包 yum install mercurial -y # 安装git包 yum install git -y # 安装gcc 主要是Cgo yum install gcc -y # wget 下载golang的压缩包 # 可以去代理网站下载 https://golang.google.cn/dl/ wget https://golang.google.cn/dl/go1.14.6.linux-amd64.tar.gz tar -zxvf *tar.gz # 打开系统环境变量声明文件添加环境变量 vi /etc/profile export GOROOT= export PATH= export GOPATH= # 使我们添加的环境变量即使生效 source /etc/profile # 验证一下是否安装成功 go version  </description>
    </item>
    
    <item>
      <title>Got下载工具</title>
      <link>https://liuzeng01.github.io/programing/go/note/august/got/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/note/august/got/</guid>
      <description> 1.安装 go get github.com/melbahja/got/cmd/got 或者直接下载release包也可以
2. 命令行使用方法 got https://example.com/file.mp4 got --out /path/to/save https://example.com/file.mp4 3. 代码中引用 package main import &amp;#34;log&amp;#34; import &amp;#34;github.com/melbahja/got&amp;#34; func main() { dl, err := got.New(&amp;#34;https://golang.google.cn/dl/go1.14.7.windows-amd64.zip&amp;#34;, &amp;#34;go.zip&amp;#34;) if err != nil { log.Fatal(err) } // Start the download 	err = dl.Start() } //可以包装到携程里面  Back</description>
    </item>
    
    <item>
      <title>Harbor 部署</title>
      <link>https://liuzeng01.github.io/linux/docker/cmd/harbor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/linux/docker/cmd/harbor/</guid>
      <description>1. 介绍 Harbor是一个用于存储和分发Docker镜像的企业级Registry服务器，通过添加一些企业必须的功能特性，例如安全、标识和管理等，扩展了开源Docker Distribution。作为一个企业级私有Registry服务器，Harbor提供了更好的性能和安全。提升用户 使用Registry构建和运行环境传输镜像的效率。Harbor支持安装在多个Registry节点的镜像资源复制，镜像全部保存在私有Registry中，确保数据和知识产权在公司内部网络中管控。另外，Harbor也提供了高级的安全特性，诸如用户管理，访问控制和活动审计等
2. 组成 1 组成Harbor的容器 Harbor大概需要以下几个容器组成：ui：Harbor的核心服务log：运行着rsyslog的容器，进行日志收集mysql：由官方mysql镜像构成的数据库容器nginx：使用nginx做反向代理registry：官方的Docker registryadminserver：Harbor的配置数据管理器jobservice：Harbor的任务管理服务redis：用于存储session 2. Harbor依赖的外部组件   Nginx（即proxy代理层）：Nginx前端代理，主要用于分发前端页面ui访问和镜像上传和下载流量。Harbor的registry,UI,token等服务，通过一个前置的反向代理统一接收浏览器、Docker客户端的请求，并将强求转发给后端不同的服务。
  Registry v2：镜像仓库，负责存储镜像文件。Docker官方镜像仓库，负责存储Docker镜像，并处理docker push/pull命令。由于我们对用户进行访问控制，即不同的用户对Docker image有不同的读写权限，Registry会指向同一个token服务，强制用户的每次docker pull/push请求都要携带一个合法的token，Registry会通过公钥对token进行解密验证。
  Database（Mysql或者Postgresql）：为core services提供数据库服务，负责存储用户权限、审计日志、Docker image分组信息等数据。
  3. Harbor自有组件 Core services（Admin Server）：这是Harbor的核心功能，主要提供以下服务：
 UI：提供图形化界面，帮助用户管理registry上的镜像（image），并对用户进行授权。 webhook：为了及时获取registry上image状态变化的情况，在Registry上配置webhook，把状态传递给UI模块。 Auth服务：负责根据用户权限给每个docker push/pull命令签发token。Docker客户端向Registry服务发起的请求，如果不包含token，会被重定向到这里，获得token后再重新向Registry进行请求。 API：提供Harbor RESTful API。  3. 部署 1. 安装docker 2. 安装docker-compose curl -L https://github.com/docker/compose/releases/download/1.25.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose docker-compose --version # 查看是否安装成功 3.</description>
    </item>
    
    <item>
      <title>Kubernetes集群中Pod获取自身信息</title>
      <link>https://liuzeng01.github.io/linux/kubernetes/template/podservice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/linux/kubernetes/template/podservice/</guid>
      <description>env: - name: MY_NODE_NAME valueFrom: fieldRef: fieldPath: spec.nodeName - name: MY_POD_NAME valueFrom: fieldRef: fieldPath: metadata.name - name: MY_POD_NAMESPACE valueFrom: fieldRef: fieldPath: metadata.namespace - name: MY_POD_IP valueFrom: fieldRef: fieldPath: status.podIP - name: MY_POD_SERVICE_ACCOUNT valueFrom: fieldRef: fieldPath: spec.serviceAccountName 用在获取pod相关信息的情景下，比如部署NSQD服务的时候，给NSQD注册一个广播地址，需要用到这个
piVersion: apps/v1 kind: Deployment metadata: labels: app: nsqd name: nsqd spec: replicas: 1 selector: matchLabels: app: nsqd template: metadata: labels: app: nsqd spec: containers: - image: nsqio/nsq name: nsqd env: - name: HOSTIP valueFrom: fieldRef: fieldPath: status.</description>
    </item>
    
    <item>
      <title>NSQ部署实践</title>
      <link>https://liuzeng01.github.io/linux/kubernetes/service/nsq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/linux/kubernetes/service/nsq/</guid>
      <description>1. nsq基本概念 2. 传统方式部署 # 第一步先下载二进制包 ## https://nsq.io/deployment/installing.html cd /usr/local/nsq-1.1.0.linux-amd64.go1.10.3/bin/ nohup ./nsqlookupd &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp; nohup ./nsqd --lookupd-tcp-address=127.0.0.1:4160 &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp; nohup ./nsqadmin --lookupd-http-address=127.0.0.1:4161 &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp; 3. docker部署 docker部署 docker pull nsqio/nsq docker run -d --name lookupd -p 4160:4160 -p 4161:4161 nsqio/nsq /nsqlookupd docker inspect -f &amp;#39;{{ .NetworkSettings.IPAddress }}&amp;#39; lookupd # 获取nsqlookup的地址172.17.0.1 docker run -d --name nsqd -p 4150:4150 -p 4151:4151 nsqio/nsq /nsqd --broadcast-address=172.17.0.1 --lookupd-tcp-address=172.17.0.2:4160 docker run -d --name nsqadmin -p 4171:4171 nsqio/nsq /nsqadmin --lookupd-http-address=172.</description>
    </item>
    
    <item>
      <title>routine</title>
      <link>https://liuzeng01.github.io/programing/go/github.com/x-mod/routine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/github.com/x-mod/routine/</guid>
      <description>github.com/x-mod/routine  为什么要写这么一个基础库呢？
  每段程序都是从 main 函数开始的，但是，却不会将整个程序的功能实现都放在 main 函数里。而是，通过层层功能的抽象与封装，最终，在 main 函数仅提供功能函数的入口。所以，当我们看很多大型程序时，其实，main 函数是非常简单的。
  但是，即使 main 函数越变越简单，有些必要的功能则是逃不掉的。例如程序启动参数、程序的信号处理，这些通常还是会放在 main 函数进行处理。
  除了以上 main 函数本身的处理以外，我发现将程序中的执行绪，也就是固定的 Go 协程的入口放在 main 函数中进行定义，可以帮助维护者更加快速的理解应用的逻辑实现。
 link 使用方法 import &amp;#34;github.com/x-mod/routine&amp;#34; //timeout timeout := routine.Timeout(time.Minute, exec) //retry retry := routine.Retry(3, exec) //repeat repeat := routine.Repeat(10, time.Second, exec) //concurrent concurrent := routine.Concurrent(4, exec) //schedule executor crontab := routine.Crontab(&amp;#34;* * * * *&amp;#34;, exec) //command command := routine.Command(&amp;#34;echo&amp;#34;, routine.ARG(&amp;#34;hello routine!</description>
    </item>
    
    <item>
      <title>Shell Case</title>
      <link>https://liuzeng01.github.io/linux/shell/shellcase/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/linux/shell/shellcase/</guid>
      <description>注意事项 开头加解释器：#!/bin/bash 语法缩进，使用四个空格；多加注释说明。 命名建议规则：变量名大写、局部变量小写，函数名小写，名字体现出实际作用。 默认变量是全局的，在函数中变量local指定为局部变量，避免污染其他作用域。 有两个命令能帮助我调试脚本：set -e 遇到执行非0时退出脚本，set-x 打印执行过程
1.获取随机字符串或数字 获取随机8位字符串：
方法1： # echo $RANDOM |md5sum |cut -c 1-8 471b94f2 方法2： # openssl rand -base64 4 vg3BEg== 方法3： # cat /proc/sys/kernel/random/uuid |cut -c 1-8 ed9e032c 获取随机8位数字：
方法1： # echo $RANDOM |cksum |cut -c 1-8 23648321 方法2： # openssl rand -base64 4 |cksum |cut -c 1-8 38571131 方法3： # date +%N |cut -c 1-8 69024815 cksum：打印CRC效验和统计字节 2.定义一个颜色输出字符串函数 方法1： function echo_color() { if [ $1 == &amp;#34;green&amp;#34; ]; then echo -e &amp;#34;\033[32;40m$2\033[0m&amp;#34; elif [ $1 == &amp;#34;red&amp;#34; ]; then echo -e &amp;#34;\033[31;40m$2\033[0m&amp;#34; fi } ​ 方法2： function echo_color() { case $1 in green) echo -e &amp;#34;[32;40m$2[0m&amp;#34; ;; red) echo -e &amp;#34;[31;40m$2[0m&amp;#34; ;; *) echo &amp;#34;Example: echo_color red string&amp;#34; esac } 使用方法：echo_color green &amp;#34;test&amp;#34; function关键字定义一个函数，可加或不加。 3.</description>
    </item>
    
    <item>
      <title>二维码生成</title>
      <link>https://liuzeng01.github.io/programing/go/note/august/qrcode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/note/august/qrcode/</guid>
      <description>使用Go语言编程时，生成任意内容的二维码是非常方便的，因为我们有go-qrcode这个库。该库的源代码托管在github上，大家可以下载使用 https://github.com/skip2/go-qrcode。 使用如下函数生成一个二维码图片
func WriteFile(content string, level RecoveryLevel, size int, filename string) error WriteFile函数的原型定义如上，它有几个参数，大概意思如下：
content表示要生成二维码的内容，可以是任意字符串。
level表示二维码的容错级别，取值有Low、Medium、High、Highest。
size表示生成图片的width和height，像素单位。
filename表示生成的文件名路径。
RecoveryLevel类型其实是个int,它的定义和常量如下。
type RecoveryLevel int const ( // Level L: 7% error recovery.  Low RecoveryLevel = iota // Level M: 15% error recovery. Good default choice.  Medium // Level Q: 25% error recovery.  High // Level H: 30% error recovery.  Highest ) RecoveryLevel越高，二维码的容错能力越好。
package main import &amp;#34;github.com/skip2/go-qrcode&amp;#34; func main() { qrcode.</description>
    </item>
    
    <item>
      <title>网络相关</title>
      <link>https://liuzeng01.github.io/essay/july/net/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/essay/july/net/</guid>
      <description>1. 网络结构 因特网服务提供商 ISP（Internet Service Provider） 不同的ISP根据其规模大小被拆分为不同层次，覆盖面积最广的就是主干ISP，通常为国家级范围，其次是地区，借助一个或多个主干并联，最后是本地ISP，可以直接连主干，也可以连地区，也就是我们最常用的（比如公司内网私有云、学校、公有云厂商）
任何一个ISP(除了顶层)都可以和多个ISP互联，成为他们的下级，也就是多宿（multi-home）, 这时候即使提供商之一出现问题，他仍然不会断网
用户那么多，主干ISP就那么几个，肯定要涵盖超大的网络数据流量，就算他有最大的带宽，可以完成流量交换，但是距离越远传输速度越慢是亘古不变的真理，如果先把相邻地区流量转发到千里之外再转发回来，是一种对网络资源的浪费
为了避免这种浪费，一种更有效快速的转发方式出现了，那就是因特网交换点 IXP （Internet Exchange Point）
这个时候BAT在干嘛呢？BAT 严格意义上来说不属于ISP，他们是提供内容的，所以被叫做因特网内容提供商 ICP（Internet Content Provider），内容供应商有内容，他们的数据中心需要和运营商网络互联互通，才能被他们的用户访问。
一般是拉通了专线边界网关协议 BGP（Border Gateway Protocol），简单来说你向BAT发消息，他们就近原则回消息，根据你访问的源地址，判断消息从哪里过来的，如果是电信，就走电信的线路回去。如果是联通，就走联通的线路回去。
以前互联网数据中心 IDC（Internet Data Center）都是运营商的，为了让自己的服务跑的更快，现在是 BAT都自建数据中心，也就是云，多余的计算资源也向外提供，把计算放到云上，这就是云计算.
再结合一个叫软件定义网络 SDN（Software Defined Network）的东西，特别是可编程路由，使得路由可以根据业务需求，流量需求，怎么省钱怎么来，用他来充当IXP的角色，成本比路由器还要便宜，而且可以按需调度，可以支持复杂流量工程，以实现分布式拒绝服务（DDOS）防止被攻击。
2. 网络协议 网络协议类似于人类协议，只不过把对话的人换成了某些硬件和软件设备（例如计算机、手机、路由器），他们之间使用的都是同一种语言（byte 流，最终解析成电信号），严格受协议的制约。
  硬件直接通过网线互联，通过协议控制网卡之间的比特流
  端系统通过阻塞控制协议，控制收发包过程中分组发送速率
  路由器协议，控制分组从源到目的地之间的路径
  七层协议 从第七层到第一层，分别对应了不同的一个数据包（报文）在不同解决的不同处理办法（协议），每个报文在传输出去的时候会经历打包的过程，套七层外套，在接收和传递的时候会经历拆包的过程，脱下七层衣服。
每一层都会携带一些关键信息给对应的设备识别，为了保证输出包顺利的投递，在传输过程中会经历很多设备，也会经历很多次拆包打包。
交换机和路由器的区别就是，路由器在网络层，可以处理TCP/IP协议，可以把一个IP分配给多个主机而交换机不能，交换机在链路层是根据MAC寻址，可以提供防火墙功能而路由器不能。路由器主要用来连接多个网络，交换机主要用来使局域网连接更多计算机。
常见家用交换机是指二层交换机，现在有三层及三层以上的交换机可基于网络层甚至传输层工作。
没有提到会话层和表示层，我个人的理解这两层从来没有独立实现过，都是和应用层在一起实现。一般的程序员都是在应用层编程，应用层主要加入了会话保持、断点下载能力，表示层主要是做数据加密解密压缩以及转码（虚拟终端协议 VTP，定义了统一的字符集、终端命令、格式控制符等等）的工作，比如大部分主机使用ASCII码，IBM 主机使用 EBCDIC 编码
有一个安全加密层，很多人都使用过，只是一直没有人想去划分层次结构，它的名字叫SSL/TLS，有了安全层提供的服务，位于应用层的HTTP/SMTP/FTP，都可以在其名字后加一个S（Security），比如HTTPS，其实这个世界压根不存在HTTPS协议，只有HTTP协议，加上 S 的后缀只是告诉大家HTTP使用的是六层结构，有了SSL/TLS的安全保护。
网络延迟丢包 为什么高峰期就会卡，不应该是我独享的宽带吗？事实上是共享的，在介绍为什么共享之前，先介绍下传输过程中产生的速度损耗。
还是让我们回到最常用的分组交换，分组交换我们说过，他把报文切片，变成一个一个的数据包进行传输，在传输给分组交换机的时候，交换机本身会进行一些包检查，这里浪费的时间叫节点处理时延（nodal processing delay）
多数分组交换机在链路的输入端使用存储转发传输（store-and-forward transmission）机制，在交换机输出该分组的第一个比特之前，必须接收到整个分组，这个等待的时间叫存储转发时延</description>
    </item>
    
    <item>
      <title>Aliyun Registry</title>
      <link>https://liuzeng01.github.io/linux/docker/cmd/aliyunrepo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/linux/docker/cmd/aliyunrepo/</guid>
      <description> 1. 登陆阿里云的registry sudo docker login --username=liuzeng_icloud registry.cn-hangzhou.aliyuncs.com 2. 从Registry中拉取镜像 sudo docker pull registry.cn-hangzhou.aliyuncs.com/liuzeng01/myrepo:[镜像版本号] 3. 将镜像推送到Registry sudo docker login --username=liuzeng_icloud registry.cn-hangzhou.aliyuncs.com sudo docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/liuzeng01/myrepo:[镜像版本号] sudo docker push registry.cn-hangzhou.aliyuncs.com/liuzeng01/myrepo:[镜像版本号]  Back</description>
    </item>
    
    <item>
      <title>cobra</title>
      <link>https://liuzeng01.github.io/programing/go/github.com/spf13/cobra/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/github.com/spf13/cobra/</guid>
      <description>cobraCobra 是一个用来创建命令行的 golang 库，同时也是一个用于生成应用和命令行文件的程序, 包括docker，k8s 都用的类似方式去实现，用于实现CLI非常好用可提供的功能点  简易的子命令行模式，如 app server， app fetch等等 完全兼容posix命令行模式 嵌套子命令subcommand 支持全局，局部，串联flags 使用Cobra很容易的生成应用程序和命令，使用cobra create appname和cobra add cmdname 如果命令输入错误，将提供智能建议，如 app srver，将提示srver没有，是否是app server 自动生成commands和flags的帮助信息 自动生成详细的help信息，如app help 自动识别-h，&amp;ndash;help帮助flag 自动生成应用程序在bash下命令自动完成功能 自动生成应用程序的man手册 命令行别名 自定义help和usage信息 可选的紧密集成的viper apps  安装方法 go get -v github.com/spf13/cobra/cobra
使用方法 1. 新建一个cobra项目 cobra init --pkg-name cobrademo
2. 目录结构 ▾ demo ▾ cmd/ root.go main.go main.go package main import ( &amp;#34;GoStudy/week16/cobrademo/cmd&amp;#34; ) func main() { cmd.</description>
    </item>
    
    <item>
      <title>Context</title>
      <link>https://liuzeng01.github.io/programing/go/note/july/context/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/note/july/context/</guid>
      <description>context源码阅读 1. 什么是 context Go 1.7 标准库引入 context，中文译作“上下文”，准确说它是 goroutine 的上下文，包含 goroutine 的运行状态、环境、现场等信息。
context 主要用来在 goroutine 之间传递上下文信息，包括：取消信号、超时时间、截止时间、k-v 等。
随着 context 包的引入，标准库中很多接口因此加上了 context 参数，例如 database/sql 包。context 几乎成为了并发控制和超时控制的标准做法。
2. 为什么有 context Go 常用来写后台服务，通常只需要几行代码，就可以搭建一个 http server。
在 Go 的 server 里，通常每来一个请求都会启动若干个 goroutine 同时工作：有些去数据库拿数据，有些调用下游接口获取相关数据…… 这些 goroutine 需要共享这个请求的基本数据，例如登陆的 token，处理请求的最大超时时间（如果超过此值再返回数据，请求方因为超时接收不到）等等。当请求被取消或是处理时间太长，这有可能是使用者关闭了浏览器或是已经超过了请求方规定的超时时间，请求方直接放弃了这次请求结果。这时，所有正在为这个请求工作的 goroutine 需要快速退出，因为它们的“工作成果”不再被需要了。在相关联的 goroutine 都退出后，系统就可以回收相关的资源。
再多说一点，Go 语言中的 server 实际上是一个“协程模型”，也就是说一个协程处理一个请求。例如在业务的高峰期，某个下游服务的响应变慢，而当前系统的请求又没有超时控制，或者超时时间设置地过大，那么等待下游服务返回数据的协程就会越来越多。而我们知道，协程是要消耗系统资源的，后果就是协程数激增，内存占用飙涨，甚至导致服务不可用。更严重的会导致雪崩效应，整个服务对外表现为不可用，这肯定是 P0 级别的事故。这时，肯定有人要背锅了。
其实前面描述的 P0 级别事故，通过设置“允许下游最长处理时间”就可以避免。例如，给下游设置的 timeout 是 50 ms，如果超过这个值还没有接收到返回数据，就直接向客户端返回一个默认值或者错误。例如，返回商品的一个默认库存数量。注意，这里设置的超时时间和创建一个 http client 设置的读写超时时间不一样，这里不详细展开。
context 包就是为了解决上面所说的这些问题而开发的：在 一组 goroutine 之间传递共享的值、取消信号、deadline…
用简练一些的话来说，在Go 里，我们不能直接杀死协程，协程的关闭一般会用 channel+select 方式来控制。但是在某些场景下，例如处理一个请求衍生了很多协程，这些协程之间是相互关联的：需要共享一些全局变量、有共同的 deadline 等，而且可以同时被关闭。再用 channel+select 就会比较麻烦，这时就可以通过 context 来实现。</description>
    </item>
    
    <item>
      <title>Gin</title>
      <link>https://liuzeng01.github.io/essay/july/gin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/essay/july/gin/</guid>
      <description>1. gin入门使用 package main import ( &amp;#34;github.com/gin-gonic/gin&amp;#34; &amp;#34;time&amp;#34; ) func main() { r := gin.Default() r.GET(&amp;#34;/&amp;#34;, func(ctx *gin.Context) { ctx.JSON(200,gin.H{ &amp;#34;Content&amp;#34;:&amp;#34;This is the gin demo&amp;#34;, &amp;#34;Time&amp;#34;:time.Now(), }) }) r.Run(&amp;#34;:8080&amp;#34;) } 输出日志
[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.[GIN-debug] [WARNING] Running in &amp;quot;debug&amp;quot; mode. Switch to &amp;quot;release&amp;quot; mode in production.- using env:	export GIN_MODE=release- using code:	gin.SetMode(gin.ReleaseMode)[GIN-debug] GET / --&amp;gt; main.</description>
    </item>
    
    <item>
      <title>Golang面试题</title>
      <link>https://liuzeng01.github.io/essay/july/golang/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/essay/july/golang/</guid>
      <description>1. 面试题 golang面试题 2. 解答 1. 选择题 1. 属于关键字的是 func struct Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。大写字母和小写字母是不同的：heapSort和Heapsort是两个不同的名字。
Go语言中类似if和switch的关键字有25个；关键字不能用于自定义名字，只能在特定语法结构中使用。
break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 此外，还有大约30多个预定义的名字，比如int和true等，主要对应内建的常量、类型和函数。
内建常量: true false iota nil 内建类型: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error 内建函数: make len cap new append copy close delete complex real imag panic recover 这些内部预先定义的名字并不是关键字，你可以在定义中重新使用它们。在一些特殊的场景中重新定义它们也是有意义的，但是也要注意避免过度而引起语义混乱。</description>
    </item>
    
    <item>
      <title>gRPC</title>
      <link>https://liuzeng01.github.io/programing/go/note/july/grpc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/note/july/grpc/</guid>
      <description>1. gRPC  gRPC是一个高性能、开源和通用的RPC框架，面向移动和HTTP/2设计。目前提供C、Java和Go语言版本，分别是grpc、grpc-java、grpc-go。gRPC基于HTTP/2标准设计，带来诸如双向流、流控、头部压缩、单TCP连接上的多复用请求等特性。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。gRPC由google开发，是一款语言中立、平台中立、开源的远程过程调用系统。 grpc具体是什么  在gRPC里客户端应用可以像调用本地对象一样直接调用另一台不同机器上服务端应用的方法，使得你能够更容易地创建分布式应用和服务。与许多RPC系统类似，gRPC也是基于以下理念：定义一个服务，指定其能够被远程调用的方法（包括参数和返回类型）。在服务端实现这个接口，并运行一个gRPC服务器来处理客户端调用。在客户端拥有一个存根能够像服务端一样的方法。gRPC客户端和服务端可以在多种环境中运行和交互，从google内部的服务器到你的笔记本，并且可以使用任何gRPC支持的语言编写。所以你可以很容易滴用Java创建一个gRPC服务端，用go、python、ruby来创建客户端。此外，google最新api将有gRPC版本的接口，使你很容易地将Google的功能集成到你的应用中。 2. protoc 与 protocol buffer  gRPC默认使用protocol buffers，这是google开源的一套成熟的结构数据序列化机制（当然也可以使用其他数据格式如JSON）可以用proto files创建gRPC服务，用protocol buffers消息类型来定义方法参数和返回类型。 3. 使用实例 3.1 Unary RPC proto syntax = &amp;#34;proto3&amp;#34;;package helloworld;service Greeter{ rpc sayhello(HelloRequest) returns (HelloReply){}}message HelloRequest{ string name = 1;}message HelloReply{ string message =1;}具体使用： 1. 第一行声明语法 2. 接下来定义RPC服务，入参与出参 3. 定义入参结构体，注意语法结构 4. 定义出参结构体
 支持的数据类型  基本类型： bool , string ,bytes([]byte),int32,int64,uint32,uint64,double(float64),float(float32) 嵌套类型： 相当于Go语言的结构体嵌套 oneof: 使用时只能定义其中的一个 enum： 使用时定义的类型需要为其中枚举的类型 map: 相当于go语言的map,定义方式为map&amp;lt;string,string&amp;gt; 声明消息体的时候，可以加上repeat字段，表示可以重复。相当于动态数组    接下来需要使用工具生成调用的文件</description>
    </item>
    
    <item>
      <title>hugo</title>
      <link>https://liuzeng01.github.io/programing/go/github.com/gohugoio/hugo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/github.com/gohugoio/hugo/</guid>
      <description>DescriptionHugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。 Hugo采用 Go 编程语言开发，Hugo 的设计目标是让创建网站重新变得有趣。Show More Hugo 是一个通用的网站框架。从技术上讲，Hugo 是一个静态站点生成器。与动态构建页面的系统不同，Hugo 在创建或更新内容时构建页面。由于网站的浏览频率远高于编辑频率，因此 Hugo 旨在为您的网站最终用户提供最佳的浏览体验，并为网站作者提供理想的写作体验。使用 Hugo 构建的网站非常快速和安全。Hugo 构建的网站可以托管在任何地方，包括 Netlify、Heroku、GoDaddy、DreamHost、GitHub Pages、GitLab Pages、Surge、Aerobatic、Firebase、Google Cloud Storage、Amazon S3、Rackspace、Azure, 和 CloudFront，并且与 CDN 更配。Hugo 网站在运行时不需要数据库或依赖于诸如 Ruby、Python 或 PHP 等昂贵的运行时环境。我们认为 Hugo 是一个理想的网站创建工具，具有几乎即时的构建时间，能够在网站修改时即刻重建。
1. Hugo 部署   二进制安装（推荐：简单、快速） 到 Hugo Releases 下载对应的操作系统版本的Hugo二进制文件（hugo或者hugo.exe）
  编译部署 熟悉Go语言的朋友可以试下这个方法，不过great wall的存在让依赖不太好下载。不过下载下之后可以自己进行魔改。geek们可以试下。
go get -u -v github.com/spf13/hugo
  开始建立hugo project hugo new site mydocs 建立好之后的目录结构为</description>
    </item>
    
    <item>
      <title>kubectl命令用法</title>
      <link>https://liuzeng01.github.io/linux/kubernetes/tips/kubectl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/linux/kubernetes/tips/kubectl/</guid>
      <description>1. 基础命令： create，delete，get，run，expose，set，explain，edit
create 命令：根据文件或者输入来创建资源 kubectl create -f demo-deployment.yaml kubectl create -f demo-service.yaml delete 命令：删除资源 # 根据yaml文件删除对应的资源，但是yaml文件并不会被删除，这样更加高效 kubectl delete -f demo-deployment.yaml kubectl delete -f demo-service.yaml # 也可以通过具体的资源名称来进行删除，使用这个删除资源，同时删除deployment和service资源 kubectl delete 具体的资源名称 get 命令 ：获得资源信息 # 查看所有的资源信息 kubectl get all kubectl get --all-namespaces # 查看pod列表 kubectl get pod # 显示pod节点的标签信息 kubectl get pod --show-labels # 根据指定标签匹配到具体的pod kubectl get pods -l app=example # 查看node节点列表 kubectl get node # 显示node节点的标签信息 kubectl get node --show-labels # 查看pod详细信息，也就是可以查看pod具体运行在哪个节点上（ip地址信息） kubectl get pod -o wide # 查看服务的详细信息，显示了服务名称，类型，集群ip，端口，时间等信息 kubectl get svc kubectl get svc -n kube-system # 查看命名空间 kubectl get ns kubectl get namespaces # 查看所有pod所属的命名空间 kubectl get pod --all-namespaces # 查看所有pod所属的命名空间并且查看都在哪些节点上运行 kubectl get pod --all-namespaces -o wide # 查看目前所有的replica set，显示了所有的pod的副本数，以及他们的可用数量以及状态等信息 kubectl get rs # 查看已经部署了的所有应用，可以看到容器，以及容器所用的镜像，标签等信息 kubectl get deploy -o wide kubectl get deployments -o wide run 命令：在集群中创建并运行一个或多个容器镜像  语法：run NAME &amp;ndash;image=image [&amp;ndash;env=&amp;quot;key=value&amp;rdquo;] [&amp;ndash;port=port] [&amp;ndash;replicas=replicas] [&amp;ndash;dry-run=bool] [&amp;ndash;overrides=inline-json] [&amp;ndash;command] &amp;ndash; [COMMAND] [args&amp;hellip;]  # 示例，运行一个名称为nginx，副本数为3，标签为app=example，镜像为nginx:1.</description>
    </item>
    
    <item>
      <title>Kubernetes搭建</title>
      <link>https://liuzeng01.github.io/linux/kubernetes/deploy/k8sbuild/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/linux/kubernetes/deploy/k8sbuild/</guid>
      <description>K8sKubernetes作为容器编排工具，简化容器管理，提升工作效率而颇受青睐。很多新手部署Kubernetes由于“科学上网”问题举步维艰，本文以实战经验详解kubeadm不用“科学上网”部署Kubernetes的最简方法。Kubernetes（简称K8S）是开源的容器集群管理系统，可以实现容器集群的自动化部署、自动扩缩容、维护等功能。它既是一款容器编排工具，也是全新的基于容器技术的分布式架构领先方案。在Docker技术的基础上，为容器化的应用提供部署运行、资源调度、服务发现和动态伸缩等功能，提高了大规模容器集群管理的便捷性。
K8S集群中有管理节点与工作节点两种类型。管理节点主要负责K8S集群管理，集群中各节点间的信息交互、任务调度，还负责容器、Pod、NameSpaces、PV等生命周期的管理。工作节点主要为容器和Pod提供计算资源，Pod及容器全部运行在工作节点上，工作节点通过kubelet服务与管理节点通信以管理容器的生命周期，并与集群其他节点进行通信。
1. 虚拟机部署 从centos的镜像开始生成，网络模式选择NAT NAT模式子网地址192.168.24.1，子网掩码 255.255.255.0 ，网关地址 192.168.24.2 ，子网区段 192.168.24.3-192.168.24.254 配置静态IP 192.168.24.131192.168.24.132192.168.24.133 设置主机名hostname，管理节点设置主机名为 master 。 hostnamectl set-hostname master # 需要设置其他主机名称时，可将 master 替换为正确的主机名node1、node2即可。 编辑 /etc/hosts 文件，添加域名解析 cat &amp;lt;&amp;lt;EOF &amp;gt;&amp;gt;/etc/hosts 10.10.10.10 master 10.10.10.11 node1 10.10.10.12 node2 EOF 关闭防火墙、selinux和swap。 systemctl stop firewalld systemctl disable firewalld setenforce 0 sed -i &amp;#34;s/^SELINUX=enforcing/SELINUX=disabled/g&amp;#34; /etc/selinux/config swapoff -a sed -i &amp;#39;s/.*swap.*/#&amp;amp;/&amp;#39; /etc/fstab 配置内核参数，将桥接的IPv4流量传递到iptables的链 cat &amp;gt; /etc/sysctl.d/k8s.conf &amp;lt;&amp;lt;EOF net.</description>
    </item>
    
    <item>
      <title>Makefile</title>
      <link>https://liuzeng01.github.io/programing/c/makefile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/c/makefile/</guid>
      <description>  Back</description>
    </item>
    
    <item>
      <title>MySQL 30个基本问题</title>
      <link>https://liuzeng01.github.io/essay/august/mysql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/essay/august/mysql/</guid>
      <description>1. 关系型数据库 关系型数据库，是指采用了关系模型来组织数据的数据库，其以行和列的形式存储数据，以便于用户理解，关系型数据库这一系列的行和列被称为表，一组表组成了数据库。用户通过查询来检索数据库中的数据，而查询是一个用于限定数据库中某些区域的执行代码。
简单来说，关系模式就是二维表格模型。
2. 关系型数据库优势 关系型数据库的优势：
 易于理解 关系型二维表的结构非常贴近现实世界，二维表格，容易理解。 支持复杂查询 可以用 SQL 语句方便的在一个表以及多个表之间做非常复杂的数据查询。 支持事务 可靠的处理事务并且保持事务的完整性，使得对于安全性能很高的数据访问要求得以实现。  3. SQL 与 MySQL 结构化查询语言 (Structured Query Language) 简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。 MySQL在过去由于性能高、成本低、可靠性好，已经成为最流行的开源数据库，广泛地应用在 Internet 上的中小型网站中。
4. MySQL 与 MariaDB MySQL 最初由瑞典 MySQL AB 公司开发，MySQL 的创始人是乌尔夫·米卡埃尔·维德纽斯，常用昵称蒙提（Monty）。
在被甲骨文公司收购后，现在属于甲骨文公司（Oracle） 旗下产品。Oracle 大幅调涨MySQL商业版的售价，因此导致自由软件社区们对于Oracle是否还会持续支持MySQL社区版有所隐忧。
MySQL 的创始人就是之前那个叫 Monty 的大佬以 MySQL为基础成立分支计划 MariaDB
两者基本完全相同
5. MySQL 数据类型 MySQL 数据类型非常丰富，常用类型简单介绍如下：
 整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT浮点数类型：FLOAT、DOUBLE、DECIMAL字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB日期类型：Date、DateTime、TimeStamp、Time、Year其他数据类型：BINARY、VARBINARY、ENUM、SET.</description>
    </item>
    
    <item>
      <title>NAT网关配置虚拟机静态IP</title>
      <link>https://liuzeng01.github.io/linux/kubernetes/deploy/natip/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/linux/kubernetes/deploy/natip/</guid>
      <description> 1. 编辑虚拟机NAT网络配置 选择NAT模式，编辑Nat模式下子网地址，网关以及子网掩码的配置（关闭DHCP）
2. 新建虚拟机时选择NAT网络模式 3. 编辑虚拟机网络配置文件 vi /etc/sysconfig/network-scripts/ifcfg-ens33 #先修改IP为静态 BOOTPROTO=&amp;#34;static&amp;#34;# 默认为DHCP # 再在末尾写上这几句 IPADDR=192.168.24.131 #这里对应上面ipconfig输出的网段192.168.24.3 ~ 192.168.24.254范围随便选一个即可，但不要跟主机相同就行 NETMASK=255.255.255.0 GATEWAY=192.168.24.2 #这里对应上面ipconfig输出的默认网关 然后重启网络服务
systemctl restart network 接下来虚拟机就可以和同网段的主机互相通信了
systemctl stop firewalld.service  Back</description>
    </item>
    
    <item>
      <title>Powershell</title>
      <link>https://liuzeng01.github.io/essay/july/powershell/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/essay/july/powershell/</guid>
      <description> 1. 查看笔记本电脑电池信息 powercfg /batteryreport /output eport.html  Back</description>
    </item>
    
    <item>
      <title>Script命令</title>
      <link>https://liuzeng01.github.io/linux/shell/script/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/linux/shell/script/</guid>
      <description>1. script 初级用法 [root@master script]# script -h Usage: script [options] [file] Options: -a, --append append the output # 追加输出 -c, --command &amp;lt;command&amp;gt; run command rather than interactive shell # 只记录执行命令的这一条的记录 -e, --return return exit code of the child process # -f, --flush run flush after each write # 每次写入都刷新 --force use output file even when it is a link -q, --quiet be quiet # 后台执行 -t, --timing[=&amp;lt;file&amp;gt;] output timing data to stderr (or to FILE) # 记录时序数据，从stderr -V, --version output version information and exit # 版本 -h, --help display this help and exit # 帮助 执行记录</description>
    </item>
    
    <item>
      <title>SSH免密登陆</title>
      <link>https://liuzeng01.github.io/essay/july/ssh/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/essay/july/ssh/</guid>
      <description> 1. linux命令行配置方法 ssh-keygen ssh-copy-id -i ~/.ssh/id_rsa.pub 192.168.24.132 # 如果给不同主机的不同用户分发的话，加上用户的名字 ssh-copy-id -i ~/.ssh/id_rsa.pub liuzeng@192.168.24.132 2. windows配置免密登陆 # 在CMD里面运行ssh-keygen # 然后把id_rsa里面的内容复制到登陆主机用户的 authorized_keys 的后面 # 接着ssh登陆一次就行了 3. id_rsa权限问题 # linux sudo chmod 600 ~/.ssh/id_rsa # windows10 # 对id_rsa文件：右击-属性-安全-高级,首先，点击窗口左下角的“禁用继承”，然后删除“权限条目”里自己以外的人,接着重新登陆就行了 --- Back</description>
    </item>
    
    <item>
      <title>Tag</title>
      <link>https://liuzeng01.github.io/programing/go/note/july/tag/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/note/july/tag/</guid>
      <description>1. tag 结构体字段上还可以额外添加属性，用反引号（Esc键下面的那个键）包含的字符串，称之为 Tag，也就是标签
Tag 由反引号包含，由一对或几对的键值对组成，通过空格来分割键值。格式如下
`key01:&amp;#34;value01&amp;#34; key02:&amp;#34;value02&amp;#34; key03:&amp;#34;value03&amp;#34;` 2. 利用反射获取结构体字段 获取 Tag 可以分为三个步骤： 获取字段 field 获取标签 tag 获取键值对 key:value
field := reflect.TypeOf(obj).FieldByName(&amp;#34;Name&amp;#34;) //field := reflect.ValueOf(obj).Type().Field(i) // i 表示第几个字段 //field := reflect.ValueOf(&amp;amp;obj).Elem().Type().Field(i) // i 表示第几个字段  // 获取 Tag tag := field.Tag // 获取键值对 labelValue := tag.Get(&amp;#34;label&amp;#34;) labelValue,ok := tag.Lookup(&amp;#34;label&amp;#34;) 示例：
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;reflect&amp;#34; ) type person struct { Name string `label:&amp;#34;my name is&amp;#34;` Age int `label:&amp;#34;my age is &amp;#34;&amp;#39;` Addr string `label:&amp;#34;my address is &amp;#34; default:&amp;#34;unknown&amp;#34;` } func main() { p := person{ Name: &amp;#34;liuzeng&amp;#34;, Age: 25, } field ,_:= reflect.</description>
    </item>
    
    <item>
      <title>tran</title>
      <link>https://liuzeng01.github.io/programing/go/note/july/tran/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/note/july/tran/</guid>
      <description>Tran工具 使用了百度翻译的API，进行单词或者短句的翻译 主要是为了方便自己平时写一些英文文档时，词穷的情况。所以设计成了命令行程序，随时使用。   1. 入口模块 利用了cobra来进行设计
main.go package main import &amp;#34;tran/cmd&amp;#34; func main() { cmd.Execute() } //执行入口 cmd/root.go package cmd import ( &amp;#34;GoStudy/week17/tran/internal&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;github.com/spf13/cobra&amp;#34; &amp;#34;os&amp;#34; homedir &amp;#34;github.com/mitchellh/go-homedir&amp;#34; &amp;#34;github.com/spf13/viper&amp;#34; ) var cfgFile string var rootCmd = &amp;amp;cobra.Command{ Use: &amp;#34;tran&amp;#34;, Short: &amp;#34;The applicaiton to help you translate the word in the terminal&amp;#34;, Long: `The Manual method : Input your query string ,and input your target language code, E.</description>
    </item>
    
    <item>
      <title>vue &#43; docker</title>
      <link>https://liuzeng01.github.io/linux/docker/cmd/npm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/linux/docker/cmd/npm/</guid>
      <description>1. NPM 环境搭建 1.root 登录linux 2.cd /usr/loacl/node/ 没有目录就自己创建一个 3.wget https://npm.taobao.org/mirrors/node/v4.4.7/node-v4.4.7-linux-x64.tar.gz 4.tar -zxvf node-v4.4.7-linux-x64.tar.gz 5.rm -rf node-v4.4.7-linux-x64.tar.gz 6.ln -s /usr/local/node/node-v4.4.7-linux-x64/bin/npm /usr/local/bin/npm 7.ln -s /usr/local/node/node-v4.4.7-linux-x64/bin/node /usr/local/bin/node 8.npm -v 2. Vue项目初始化 1. 安装vue npm install -g vue 2. 安装vue脚手架 npm install -g @vue/cli 3. 直接使用 Vue 脚手架构建项目 vue create docker-demo 4. 安装下yarn yum install yarn/npm install -g yarn 5. 启动下项目 yarn serve 6. 项目打包 yarn build 3. 制作docker镜像 1. cd docker-demo &amp;amp;&amp;amp; touch Dockerfile 2.</description>
    </item>
    
    <item>
      <title>分阶段构建减小go镜像体积</title>
      <link>https://liuzeng01.github.io/linux/docker/dockerfile/godockerfile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/linux/docker/dockerfile/godockerfile/</guid>
      <description> 分阶段构建主要思路 第一阶段 使用golang镜像构建出可执行文件 第二阶段 使用busybox:glibc小镜像作为基础镜像镜像文件 第一阶段 FROMgolang AS my_build_stageCOPY hello.go .RUN go build hello.go第二阶段 FROMbusybox:glibcCOPY --from=my_build_stage hello .// COPY --from=0 hello . 与COPY --from=my_build_stage hello .等效 0表示第一阶段CMD [&amp;#34;./hello&amp;#34;] Go项目应用的Dockerfile通常大概类似这样，但是每个项目的细节可能有所不同。
FROM golang:alpine指定了开始阶段的基础映像（其中包含Go工具和库，用于构建程序），AS build是给这个阶段取名为build。 golang:alpine指定了Go基础映像的alpine版本， alpine是专门为容器设计的小型Linux发行版。这个Dockerfile中使用了两次FROM指令，第二条FROM scratch行，它告诉Docker从一个全新的，完全空的容器镜像重新开始，然后将上个阶段编译好的程序复制到其中。这个才是我们随后将用于运行的Go应用程序的容器镜像。
scratch镜像是Docker项目预定义的最小的镜像。 Docker用于Go程序的多阶段构建很常见，使用scratch镜像可以节省大量空间，因为我们实际上不需要Go工具或其他任何东西来运行我们的编译好的程序，这可能也是Go在容器时代的一个优势吧。
 Back</description>
    </item>
    
    <item>
      <title>循环读取输入</title>
      <link>https://liuzeng01.github.io/programing/go/note/july/scanner/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/note/july/scanner/</guid>
      <description> 循环读取用户输入 package main import ( &amp;#34;bufio&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) func main() { scanner() } func scanner() { fmt.Printf(&amp;#34;----&amp;gt;&amp;#34;) scanner := bufio.NewScanner(os.Stdin) for scanner.Scan() { fmt.Println(scanner.Text()) fmt.Printf(&amp;#34;----&amp;gt;&amp;#34;) } } </description>
    </item>
    
    <item>
      <title>kube proxy</title>
      <link>https://liuzeng01.github.io/linux/kubernetes/tips/proxy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/linux/kubernetes/tips/proxy/</guid>
      <description>1. 利用kubectl proxy kubectl proxy curl -v 127.0.0.1:8001 2. 在容器中访问 # 在外部允许匿名访问api kubectl create clusterrolebinding test:anonymous --clusterrole=cluster-admin --user=system:anonymous # 容器内需要有curl curl --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt https://kubernetes # 这个cacert证书指定的是ca证书的位置 ，后面的kubernetes指定的是k8s集群中默认的服务，在pod里面可以通过环境变量或者dns直接访问他 export CURL_CA_BUNDLE=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt # 可以直接指定ca在环境变量里面，这样容器就可以直接访问api了 3. 利用sidecar container访问 这个其实就是启动了一个类似于proxy的代理容器，和第一个方法是非常相同的 首先把系统的kubectl拷贝到当前目录下，写个简单的启动脚本和dockerfile
#!/bin/sh API_SERVER=&amp;#34;https://$KUBERNETES_SERVICE_HOST:$KUBERNETES_SERVICE_PORT&amp;#34; CA_CRT=&amp;#34;/var/run/secrets/kubernetes.io/serviceaccount/ca.crt&amp;#34; TOKEN=&amp;#34;$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)&amp;#34; /kubectl proxy --server=&amp;#34;$API_SERVER&amp;#34; --certificate-authority=&amp;#34;$CA_CRT&amp;#34; --token=&amp;#34;$TOKEN&amp;#34; --accept-paths=&amp;#39;^.*&amp;#39; dockerfile
FROMalpineADD . .RUN chmod +x proxy.sh &amp;amp;&amp;amp; chmod +x kubectlENTRYPOINT /proxy.sh然后 docker build docker push就行了 编一个pod的yaml
apiVersion: v1 kind: Pod metadata: name: curl-with-ambassador spec: containers: - name: main image: nginx command: [&amp;#34;sleep&amp;#34;, &amp;#34;9999999&amp;#34;] - name: proxy image: 192.</description>
    </item>
    
    <item>
      <title>Supervisor</title>
      <link>https://liuzeng01.github.io/linux/shell/supervisor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/linux/shell/supervisor/</guid>
      <description>进程管理工具Supervisor是一个进程管理工具，当进程中断的时候Supervisor能自动重新启动它。可以运行在各种类unix的机器上，supervisor就是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。1. 基本介绍   supervisord
运行 Supervisor 时会启动一个进程 supervisord，它负责启动所管理的进程，并将所管理的进程作为自己的子进程来启动，而且可以在所管理的进程出现崩溃时自动重启。
  supervisorctl
是命令行管理工具，可以用来执行 stop、start、restart 等命令，来对这些子进程进行管理。
supervisor是所有进程的父进程，管理着启动的子进展，supervisor以子进程的PID来管理子进程，当子进程异常退出时supervisor可以收到相应的信号量。
  2. 安装方法及配置 1. 安装 yum instal supervisor # 查看安装是否成功 echo_supervisord_conf 2. 配置 # 创建目录，初始化配置文件 mkdir /usr/supervisor echo_supervisord_conf &amp;gt; /usr/supervisor/supervisord.conf # 新增配置信息文件夹 mkdir /usr/supervisor/supervisord.d/ # 修改系统配置文件 vim /usr/supervisor/supervisord.conf # 添加配置文件路径 [include] files = /usr/supervisor/supervisord.d/*.conf files = /usr/supervisor/supervisord.d/*.ini # [inet_http_server] port=127.0.0.1:9001 ;IP按需配置 username=user password=123 # 启动supervisord supervisord -c /usr/supervisor/supervisord.</description>
    </item>
    
    <item>
      <title>一次XHR错误的排查过程</title>
      <link>https://liuzeng01.github.io/essay/august/xhr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/essay/august/xhr/</guid>
      <description> EROR问题 ： 在使用VSCode打开远程SSH服务器的时候，迟迟打不开终端，MobaXterm使用是正常的。报错为XHR error1. 排查是否属于密钥的问题 cat /root/.ssh/authorized_keys # 查看与本机密钥是否一致 2. 排查时区问题 yum install ntp cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime ntpdate cn.pool.ntp.org date 3. 排查下载插件的问题 将时区与本地的时间校对之后还是打不开，怀疑是之前插件的时区设置也有问题 ，于是删除了 vscode下面的bin，重新加载后解决
搜索历史命令： ctrl +r </description>
    </item>
    
    <item>
      <title>GlusterFS</title>
      <link>https://liuzeng01.github.io/linux/kubernetes/deploy/glusterfs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/linux/kubernetes/deploy/glusterfs/</guid>
      <description>简介Glusterfs是一个开源分布式文件系统，具有强大的横向扩展能力，可支持数PB存储容量和数千客户端，通过Infiniband RDMA 或Tcp/Ip 方式将许多廉价的x86 主机，通过网络互联成一个并行的网络文件系统。具有可扩展性、高性能、高可用性等特点glusterfs堆栈式结构 Glusterfs是根据fuse提供的接口实现的一个用户态的文件系统，主要包括gluster、glusterd、glusterfs和glusterfsd四大模块组成：
 gluster：是cli命令执行工具，主要功能是解析命令行参数，然后把命令发送给glusterd模块执行。 glusterd:是一个管理模块，处理gluster发过来的命令，处理集群管理、存储池管理、brick管理、负载均衡、快照管理等。集群信息、存储池信息和快照信息等都是以配置文件的形式存放在服务器中，当客户端挂载存储时，glusterd会把存储池的配置文件发送给客户端。 glusterfsd：是服务端模块，存储池中的每个brick都会启动一个glusterfsd进程。此模块主要是处理客户端的读写请求，从关联的brick所在磁盘中读写数据，然后返回给客户端。 glusterfs：是客户端模块，负责通过mount挂载集群中某台服务器的存储池，以目录的形式呈现给用户。当用户从此目录读写数据时，客户端根据从glusterd模块获取的存储池的配置文件信息，通过DHT算法计算文件所在服务器的brick位置，然后通过Infiniband RDMA 或Tcp/Ip 方式把数据发送给brick，等brick处理完，给用户返回结果。存储池的副本、条带、hash、EC等逻辑都在客户端处理。  glusterfs几种volume模式  一、 默认模式，既DHT, 也叫 分布卷: 将文件已hash算法随机分布到 一台服务器节点中存储。 gluster volume create test-volume server1:/exp1 server2:/exp2 二、 复制模式，既AFR, 创建volume 时带 replica x 数量: 将文件复制到 replica x 个节点中。 gluster volume create test-volume replica 2 transport tcp server1:/exp1 server2:/exp2 三、 条带模式，既Striped, 创建volume 时带 stripe x 数量： 将文件切割成数据块，分别存储到 stripe x 个节点中 ( 类似raid 0 )。 gluster volume create test-volume stripe 2 transport tcp server1:/exp1 server2:/exp2 四、 分布式条带模式（组合型），最少需要4台服务器才能创建。 创建volume 时 stripe 2 server = 4 个节点： 是DHT 与 Striped 的组合型。 gluster volume create test-volume stripe 2 transport tcp server1:/exp1 server2:/exp2 server3:/exp3 server4:/exp4 五、 分布式复制模式（组合型）, 最少需要4台服务器才能创建。 创建volume 时 replica 2 server = 4 个节点：是DHT 与 AFR 的组合型。 gluster volume create test-volume replica 2 transport tcp server1:/exp1 server2:/exp2　server3:/exp3 server4:/exp4 六、 条带复制卷模式（组合型）, 最少需要4台服务器才能创建。 创建volume 时 stripe 2 replica 2 server = 4 个节点： 是 Striped 与 AFR 的组合型。 gluster volume create test-volume stripe 2 replica 2 transport tcp server1:/exp1 server2:/exp2 server3:/exp3 server4:/exp4 七、 三种模式混合, 至少需要8台 服务器才能创建。 stripe 2 replica 2 , 每4个节点 组成一个 组。 gluster volume create test-volume stripe 2 replica 2 transport tcp server1:/exp1 server2:/exp2 server3:/exp3 server4:/exp4 server5:/exp5 server6:/exp6 server7:/exp7 server8:/exp8  部署 # 主机信息 三节点 192.</description>
    </item>
    
    <item>
      <title>Go项目分阶段构建实践</title>
      <link>https://liuzeng01.github.io/linux/docker/dockerfile/practice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/linux/docker/dockerfile/practice/</guid>
      <description>1. main.go package main import ( &amp;#34;fmt&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;path/filepath&amp;#34; ) func main() { p, _ := filepath.Abs(filepath.Dir(&amp;#34;dist/&amp;#34;)) http.Handle(&amp;#34;/&amp;#34;, http.FileServer(http.Dir(p))) err := http.ListenAndServe(&amp;#34;:80&amp;#34;, nil) if err != nil { fmt.Println(err) } } 一个很简单的静态文件服务器，可以将dist下面的静态网页展示出去。没有用到第三方库
2. Dockerfile FROMgolang:alpine AS build-envADD . /srcRUN cd /src &amp;amp;&amp;amp; go build -o app# final stageMAINTAINERliuzeng01FROMalpineWORKDIR/appRUN mkdir distCOPY --from=build-env /src/app /appENTRYPOINT ./app分两个阶段构建，第一个阶段编译Go程序，第二个阶段将编译好的执行性文件拷贝到运行目录下。 执行下构建
[root@master hugosite]# docker build -t staticsite . Sending build context to Docker daemon 12.6MB Step 1/9 : FROM golang:alpine AS build-env ---&amp;gt; 30df784d6206 Step 2/9 : ADD .</description>
    </item>
    
    <item>
      <title>nutsdb</title>
      <link>https://liuzeng01.github.io/programing/go/github.com/xujiajun/nutsdb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/github.com/xujiajun/nutsdb/</guid>
      <description>DescriptionNutsDB是纯Go语言编写一个简单、高性能、内嵌型、持久化的key-value数据库。
NutsDB支持事务，从v0.2.0之后的版本开始支持ACID的特性，建议使用最新的release版本。v0.2.0之前的版本，保持高性能，没有作sync，但是具备高性能的写（本地测试，百万数据写入达40~50W+/s）。所有的操作都在事务中执行。NutsDB从v0.2.0版本开始支持多种数据结构，如列表(list)、集合(set)、有序集合(sorted set)。从0.4.0版本开始增加自定义配置读写方式、启动时候的文件载入方式、sync是否开启等
github.com/xujiajun/nutsdb  官方文档
1. 安装 go get -u github.com/xujiajun/nutsdb 2. 使用 开启数据库 package main import ( &amp;#34;log&amp;#34; &amp;#34;github.com/xujiajun/nutsdb&amp;#34; ) func main() { opt := nutsdb.DefaultOptions opt.Dir = &amp;#34;/tmp/nutsdb&amp;#34; //这边数据库会自动创建这个目录文件 	db, err := nutsdb.Open(opt) if err != nil { log.Fatal(err) } defer db.Close() ... } 这里的默认配置是
var DefaultOptions = Options{ EntryIdxMode: HintKeyValAndRAMIdxMode, //EntryIdxMode 代表索引entry的模式. EntryIdxMode 包括选项: HintKeyValAndRAMIdxMode 、HintKeyAndRAMIdxMode和 HintBPTSparseIdxMode。其中HintKeyValAndRAMIdxMode 代表纯内存索引模式（key和value都会被cache）。 HintKeyAndRAMIdxMode 代表内存+磁盘的索引模式（只有key被cache）。 HintBPTSparseIdxMode（v0.</description>
    </item>
    
    <item>
      <title>dockerfile使用注意事项</title>
      <link>https://liuzeng01.github.io/linux/docker/dockerfile/tips/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/linux/docker/dockerfile/tips/</guid>
      <description> 1. 使用官方镜像 官方镜像往往更加稳定，安全
2. From合适的镜像 注意alpine ，runtime ，sdk等等镜像的区别。尽量使用alpine镜像，体积更小。SDK 往往集成了开发的所有环境，这个时候如果为了减小镜像体积的话，可以使用Runtime镜像作为应用的运行镜像。
3. 只Copy需要的文件，而不是拷贝所有文件 4. 多阶段构建 5. 多利用Cache，来减小重复构建时候的耗时 6. 合理使用Run命令。将需要更新软件或者安装应用的步骤放到一起 这也是为了尽量减小构建的中间镜像的层数和大小。同时注意和经常修改的指令分开，这个主要是为了利用缓存，提升构建速度。
7. 使用.dockerignore文件来忽略不需要构建或者缓存的文件 8. 注意指令顺序。将不变的放在前面，经常修改的放在后面  Back</description>
    </item>
    
    <item>
      <title>Gitlab&#43;kubernetes</title>
      <link>https://liuzeng01.github.io/linux/kubernetes/deploy/gitlab/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/linux/kubernetes/deploy/gitlab/</guid>
      <description> 1. 在kubernetes集群中部署Gitlab 2. 在kubernetes集群中部署Jenkins 3. 利用Jenkins配置Gitlab的CICD流程 4. 持续部署镜像应用到Kubernetes  Back</description>
    </item>
    
    <item>
      <title>Go数据结构</title>
      <link>https://liuzeng01.github.io/programing/go/note/july/golang%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/note/july/golang%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>golang本质是全局按照值传递的，也就是copy值，那么你必须知道你的内存对象是包含哪些内容，才能清楚掌握你在copy值的时候复制了哪些东西  num bool string array slice map channel interface  package main func main () { var n int64 = 11 //n就是一个8字节的数据块。 var b bool = true //是一个1字节的数据块。  var s string = &amp;#34;test-string-1&amp;#34; //x  var a [3]bool = [3]bool{true, false, true} var sl []int = []int{1,2,3,4} var m map[int]string var c chan int var in interface{} _, _, _, _, _, _, _, _ = n, b, s, a, sl, m, c , in } string类型 (gdb) pt s type = struct string { uint8 *str; int len; } //string类型在go里是一个复合类型，s变量是一个16字节的变量。其中str字段指向字符串存储的地方 //s就是代表了一个16字节的数据块。所以我们每次定义一个string变量，除了字符序列，s的本身结构是分配16个字节在栈上。 数组类型 //数组类型，就是在地址空间中连续的一段内存块，和c一样（旁白：和c一样，都是平坦的内存结构）。 (gdb) p &amp;amp;a $13 = ([3]bool *) 0xc00003070d (gdb) x/6bx 0xc00003070d 0xc00003070d: 0x01 0x00 0x01 0x0b 0x00 0x00 切片类型 // 是个复合类型，变量本身是一个管理结构（和string一样），这个管理结构管理着一段连续的内存 (gdb) pt sl type = struct []int { int *array; int len; int cap; } map 类型 和 channel 类型 map类型和channel类型特别提一点，变量本身本质上是一个指针类型。也就是说上面我们定义了两个变量m，c，从内存分配的角度来讲，只在栈上分配了一个指针变量，并且这个指针还是nil值，所以我们经常看到 go 的一个特殊说明：slice，map，channel 这三种类型必须使用make来创建，就是这个道理。因为如果仅仅定义了类型变量，那仅仅是代表了分配了这个变量本身的内存空间，并且初始化是nil，一旦你直接用，那么就会导致非法地址引用的问题。slice 的24个字节的管理空间，map和channel的一个指针8个字节的空间。那么如果是调用了make，其实就会把下面的结构分配并初始化出来。</description>
    </item>
    
    <item>
      <title>Go语言查询不定字段</title>
      <link>https://liuzeng01.github.io/programing/go/note/july/sqlnodefine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/note/july/sqlnodefine/</guid>
      <description>package main import ( &amp;#34;database/sql&amp;#34; &amp;#34;fmt&amp;#34; _ &amp;#34;github.com/go-sql-driver/mysql&amp;#34; ) func main() { //连接数据库 	db, err := sql.Open(&amp;#34;mysql&amp;#34;, &amp;#34;golang:golang@tcp(localhost:3306)/gostudy?charset=utf8&amp;#34;) if err != nil { fmt.Println(&amp;#34;连接数据库失败&amp;#34;, err.Error()) return } defer db.Close() //查询数据库 	query, err := db.Query(&amp;#34;select * from event_filelist&amp;#34;) if err != nil { fmt.Println(&amp;#34;查询数据库失败&amp;#34;, err.Error()) return } defer query.Close() //读出查询出的列字段名 	cols, _ := query.Columns() //values是每个列的值，这里获取到byte里 	values := make([][]byte, len(cols)) //query.Scan的参数，因为每次查询出来的列是不定长的，用len(cols)定住当次查询的长度 	scans := make([]interface{}, len(cols)) //让每一行数据都填充到[][]byte里面 	for i := range values { scans[i] = &amp;amp;values[i] } //最后得到的map 	results := make(map[int]map[string]string) i := 0 for query.</description>
    </item>
    
    <item>
      <title>Go语言设计模式</title>
      <link>https://liuzeng01.github.io/programing/go/note/august/design/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/note/august/design/</guid>
      <description>设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。
1. 创建型模式 单例模式 单例模式算是23中设计模式里最简单的一个了，它主要用于保证一个类仅有一个实例，并提供一个访问它的全局访问点。
在程序设计中，有一些对象通常我们只需要一个共享的实例，比如线程池、全局缓存、对象池等，这种场景下就适合使用单例模式。
但是，并非所有全局唯一的场景都适合使用单例模式。比如，考虑需要统计一个API调用的情况，有两个指标，成功调用次数和失败调用次数。这两个指标都是全局唯一的，所以有人可能会将其建模成两个单例SuccessApiMetric和FailApiMetric。按照这个思路，随着指标数量的增多，你会发现代码里类的定义会越来越多，也越来越臃肿。这也是单例模式最常见的误用场景，更好的方法是将两个指标设计成一个对象ApiMetric下的两个实例ApiMetic success和ApiMetic fail。 如何判断一个对象是否应该被建模成单例？
通常，被建模成单例的对象都有“中心点”的含义，比如线程池就是管理所有线程的中心。所以，在判断一个对象是否适合单例模式时，先思考下，这个对象是一个中心点吗？
在对某个对象实现单例模式时，有两个点必须要注意：（1）限制调用者直接实例化该对象；（2）为该对象的单例提供一个全局唯一的访问方法。
我们可以利用Go语言package的访问规则来实现，将单例结构体设计成首字母小写，就能限定其访问范围只在当前package下，模拟了C++/Java中的私有构造函数；再在当前package下实现一个首字母大写的访问函数，就相当于static方法的作用了。
在实际开发中，我们经常会遇到需要频繁创建和销毁的对象。频繁的创建和销毁一则消耗CPU，二则内存的利用率也不高，通常我们都会使用对象池技术来进行优化。考虑我们需要实现一个消息对象池，因为是全局的中心点，管理所有的Message实例，所以将其实现成单例，实现代码如下
package msgpool ... // 消息池 type messagePool struct { pool *sync.Pool } // 消息池单例 var msgPool = &amp;amp;messagePool{ // 如果消息池里没有消息，则新建一个Count值为0的Message实例  pool: &amp;amp;sync.Pool{New: func() interface{} { return &amp;amp;Message{Count: 0} }}, } // 访问消息池单例的唯一方法 func Instance() *messagePool { return msgPool } // 往消息池里添加消息 func (m *messagePool) AddMsg(msg *Message) { m.pool.Put(msg) } // 从消息池里获取消息 func (m *messagePool) GetMsg() *Message { return m.</description>
    </item>
    
    <item>
      <title>grep/sed/awk</title>
      <link>https://liuzeng01.github.io/linux/shell/shellexample/grep/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/linux/shell/shellexample/grep/</guid>
      <description>1. grep 常用命令
-v 取反 -i 忽略大小写 -c 符合条件的行数 -n 输出的同时打印行号 ^* 以*开头 *$ 以*结尾 ^$ 空行 使用示例
# 查找在目标文件中含有scsi的行 grep scsi test.txt # 查看目录下所有含有scsi的文件 grep scsi -rl grep scsi -rl * grep scsi * # 反查 grep -v scsci grep -v scsci test.txt # 统计行数 grep -c kworker test.txt # 忽略大小写统计行数 grep -ic kworker test.txt # 输出行号 grep -n kworker test.txt # 输出所有以 ] 结尾的行 grep &amp;#34;]$&amp;#34; test.txt # 输出所有以 root 开始的行 grep &amp;#34;^root&amp;#34; -c test.</description>
    </item>
    
    <item>
      <title>IP</title>
      <link>https://liuzeng01.github.io/programing/go/note/july/ip/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/note/july/ip/</guid>
      <description>在cobra里面写了一个IP地址转16进制的脚本，用到了net包 package internal import ( &amp;#34;encoding/hex&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;net&amp;#34; &amp;#34;strings&amp;#34; ) func ParseIPV4(ipaddr string){ if len(ipaddr) == 0 { return } hexaddr := strings.ToUpper(hex.EncodeToString(net.ParseIP(ipaddr).To4())) fmt.Println(hexaddr) } func ParseIPV6(ipaddr string){ if len(ipaddr) == 0 { return } hexaddr := strings.ToUpper(hex.EncodeToString(net.ParseIP(ipaddr).To16())) fmt.Println(hexaddr) } //光有转16进制是不行的，还需要从16进制转回ip地址 func ParseHexToIpv4(hexstring string) { if len(hexstring) == 0 { return } var ip net.IP ip, err := hex.DecodeString(hexstring) if err != nil { fmt.Println(err) return } fmt.Println(ip.To4()) } func ParseHexToIpv6(hexstring string) { if len(hexstring) == 0 { return } var ip net.</description>
    </item>
    
    <item>
      <title>kubectl 使用技巧</title>
      <link>https://liuzeng01.github.io/linux/kubernetes/tips/kubeapi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/linux/kubernetes/tips/kubeapi/</guid>
      <description>1. kubectl 工作原理 从技术角度上看，kubectl是Kubernetes API的客户端。Kubernetes API是一个 HTTP REST API。这个API是真正的Kubernetes用户界面。Kubernetes完全受这个API控制，这意味着每个Kubernetes操作都作为API端点公开，并且可以由对此端点的HTTP请求执行。因此，kubectl的主要工作是执行对Kubernetes API的HTTP请求 Kubernetes是一个完全以资源为中心的系统。这意味着，Kubernetes维护资源的内部状态并且所有的Kubernetes操作都是针对这些资源的CRUD（增加、读取、更新、删除）操作。你完全可以通过操控这些资源（Kubernetes会根据资源的当前状态找出解决方案）来控制Kubernetes。因此，Kubernetes API reference主要是资源类型及其相关操作的列表。
Kubernetes API对于内部组件和外部用户的重复操作是Kubernetes的基本设计概念。现在，我们来总结一下Kubernetes如何工作的：
 存储后端存储（如，资源）Kubernetes的状态 API server以Kubernetes API的形式提供到存储后端的接口 所有其他Kubernetes的组件和用户通过Kubernetes API读取、监视以及操控Kubernetes的状态（如资源）。  2. 配置bash补全 sudo apt-get install bash-completion # or yum install bash-completion kubectl completion bash bash-completion安装完成之后，你需要进行一些设置，以便在所有的shell会话中获得kubectl补全脚本。一种方法是将以下命令行添加到~/.bashrc文件中：
source &amp;lt;(kubectl completion bash) 另一种可能性是将kubectl补充脚本添加到/etc/bash_completion.d目录中（如果不存在，则需要先创建它）：
kubectl completion bash &amp;gt;/etc/bash_completion.d/kubectl # /etc/bash_completion.d目录中的所有补全脚本均由bash-completion自动提供。 以上两种方法都是一样的效果。重新加载shell后，kubectl命令补全就能正常工作啦！
3. 查看API规范 当你创建YAML资源定义时，你需要知道字段以及这些资源的意义。kubectl提供了kubectl explain命令，它能在你的terminal中正确地输入所有资源规范。
kubectl explain resource[.field]... # 该命令输出所请求资源或字段的规范。kubectl explain所显示的信息与API reference中的信息相同。默认情况下，kubectl explain仅显示单个级别的字段。你可以使用--recursive标志来显示所有级别的字段： 4. 使用自定义列输出格式 自定义列输出选项的用法如下：
-o custom-columns=&amp;lt;header&amp;gt;:&amp;lt;jsonpath&amp;gt;[,&amp;lt;header&amp;gt;:&amp;lt;jsonpath&amp;gt;]... 你必须将每个输出列定义为：对：
是列的名称，你可以选择任何所需的内容。是一个选择资源字段的表达式示例： # Select all elements of a list kubectl get pods -o custom-columns=&amp;#39;DATA:spec.</description>
    </item>
    
    <item>
      <title>mod</title>
      <link>https://liuzeng01.github.io/programing/go/note/july/mod/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/note/july/mod/</guid>
      <description>modgo mod能管理的依赖包的版本，能保证在不同地方构建，获得的依赖模块是一致的。1. 常用代理地址 https://mirrors.aliyun.com/goproxy/ //阿里云镜像 https://goproxy.io https://goproxy.cn //七牛云镜像 https://athens.azurefd.net //微软镜像 2. 常用命令 * go mod init # 初始化当前目录为模块根目录，生成go.mod, go.sum文件 * go mod download # 下载依赖包 * go mod tidy # 整理检查依赖，如果缺失包会下载或者引用的不需要的包会删除 * go mod vendor # 复制依赖到vendor目录下面 * go mod # 可看完整所有的命令 ## 如果发现编译不过，可以通过下面命令列出指定mod的版本，然后go get拉指定版本号的包 go list -m -versions rsc.io/sampler go get rsc.io/sampler@v1.3.1 补充   用 go get 拉取新的依赖拉取最新的版本(优先择取 tag)：go get golang.</description>
    </item>
    
    <item>
      <title>toml</title>
      <link>https://liuzeng01.github.io/essay/july/toml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/essay/july/toml/</guid>
      <description>TOML是前GitHub CEO， Tom Preston-Werner，于2013年创建的语言，其目标是成为一个小规模的易于使用的语义化配置文件格式。TOML被设计为可以无二义性的转换为一个哈希表(Hash table)。TOML是大小写敏感的，必须是UTF-8编码。
title = &amp;#34;TOML Example&amp;#34; [owner] name = &amp;#34;Lance Uppercut&amp;#34; dob = 1979-05-27T07:32:00-08:00 # 日期是一等公民 [database] server = &amp;#34;192.168.1.1&amp;#34; ports = [ 8001, 8001, 8002 ] connection_max = 5000 enabled = true [servers] #你可以使用空格、制表符进行缩进，或者根本不缩进。TOML不关心缩进。 [servers.alpha] ip = &amp;#34;10.0.0.1&amp;#34; dc = &amp;#34;eqdc10&amp;#34; [servers.beta] ip = &amp;#34;10.0.0.2&amp;#34; dc = &amp;#34;eqdc10&amp;#34; [clients] data = [ [&amp;#34;gamma&amp;#34;, &amp;#34;delta&amp;#34;], [1, 2] ] # 数组内可以混入换行符 hosts = [ &amp;#34;alpha&amp;#34;, &amp;#34;omega&amp;#34; ] 注释 注释使用#开头</description>
    </item>
    
    <item>
      <title>tview</title>
      <link>https://liuzeng01.github.io/programing/go/github.com/rivo/tview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/github.com/rivo/tview/</guid>
      <description>github.com/rivo/tview 1. 常用的控件    TextView: A scrollable window that display multi-colored text. Text may also be highlighted. Table: A scrollable display of tabular data. Table cells, rows, or columns may also be highlighted. TreeView: A scrollable display for hierarchical data. Tree nodes can be highlighted, collapsed, expanded, and more. List: A navigable text list with optional keyboard shortcuts. InputField: One-line input fields to enter text. DropDown: Drop-down selection fields.</description>
    </item>
    
    <item>
      <title>Vim快捷键</title>
      <link>https://liuzeng01.github.io/linux/shell/vi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/linux/shell/vi/</guid>
      <description>1. 基本操作  i ：插入 ：命令行模式 esc :退出到普通模式  2. 方向快捷键  j 向上一行 k 向下一行 h 向左一个字节 l 向右一个字节 0 跳转到行头 $ 跳转行尾 w 向后一个词 b 向前一个词 G 移动到文件末尾 gg 移动到文件开头  3. 文本快捷键  ( 跳转到上一句 ) 跳转到下一句 [[ 跳转到上一部分 ]] 跳转到下一部分 [] 上一部分的末尾 ][ 上一部分的开头  4. 插入文本快捷键  a 光标后插入 A 行末插入 i 光标前插入 o 下方新开一行 O 上方新开一行  5. 特殊插入  :r [filename] 在光标后方插入文件filename的内容 :r !</description>
    </item>
    
  </channel>
</rss>