<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My Document on iNote</title>
    <link>https://liuzeng01.github.io/</link>
    <description>Recent content in My Document on iNote</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://liuzeng01.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Basic Gx Case</title>
      <link>https://liuzeng01.github.io/zsmart/pcrf/testcase/basic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/zsmart/pcrf/testcase/basic/</guid>
      <description> 1. 基础配置 pcrf侧 ocs侧 2. 测试流程 开户流程 phub对接流程 发包流程 3. 日志流程 PDE日志 SyPro日志 4. 相关问题记录 SyPro未返回policy plan code PDE进行分拣时core退出问题 PDE Down掉后ZCM自动拉起PDE，建立同一局号链路问题  Back</description>
    </item>
    
    <item>
      <title>dockerfile基础命令</title>
      <link>https://liuzeng01.github.io/linux/docker/dockerfile/command/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/linux/docker/dockerfile/command/</guid>
      <description>dockerfile 基础命令 FROM 指定基础镜像 FROM nginx
RUN 执行命令 exec 格式: RUN [&amp;quot;可执行文件&amp;quot;, &amp;quot;参数1&amp;quot;, &amp;quot;参数2&amp;quot;]RUN apt-get updateRUN apt-get install -y gcc libc6-dev makeCOPY 复制文件 COPY [&amp;quot;&amp;lt;源路径1&amp;gt;&amp;quot;,... &amp;quot;&amp;lt;目标路径&amp;gt;&amp;quot;]COPY package.json /usr/src/app/ADD 更高级的复制文件 ADD [&amp;quot;&amp;lt;源路径1&amp;gt;&amp;quot;,... &amp;quot;&amp;lt;目标路径&amp;gt;&amp;quot;]源路径可以使是url,如果是压缩包,自动解压缩,不推荐使用
FROM scratchADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gzCMD 容器启动命令 shell 格式: CMD &amp;lt;命令&amp;gt;exec 格式: CMD [&amp;quot;可执行文件&amp;quot;, &amp;quot;参数1&amp;quot;, &amp;quot;参数2&amp;quot;...]在指定了 ENTRYPOINT 指令后，用 CMD 指 定具体的参数
CMD [ &amp;quot;sh&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;echo $HOME&amp;quot; ]#CMD echo $HOMEENTRYPOINT 入口点 shell 格式: ENTRYPOINT &amp;lt;命令&amp;gt;exec 格式: ENTRYPOINT [&amp;quot;可执行文件&amp;quot;, &amp;quot;参数1&amp;quot;, &amp;quot;参数2&amp;quot;.</description>
    </item>
    
    <item>
      <title>hugo语法</title>
      <link>https://liuzeng01.github.io/essay/july/hugo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/essay/july/hugo/</guid>
      <description>1. hugo 2. Ace Document   button The button shortcode allows you to add a button to the page. This button is a HTML anchor element and can thus be used to link to another page or website.
ButtonButtonButtonButtonButtonButtonButtonUsage Place the following shortcode on the page Copy{{&amp;lt; button style=&amp;#34;STYLE&amp;#34; link=&amp;#34;https://yourwebsite.com&amp;#34; &amp;gt;}} [content] {{&amp;lt; /button &amp;gt;}} Parameters style The style parameter is directly applied to the alert as a class in the format &amp;ldquo;btn-{STYLE}&amp;quot;.</description>
    </item>
    
    <item>
      <title>Json </title>
      <link>https://liuzeng01.github.io/programing/go/note/july/json/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/note/july/json/</guid>
      <description>Json   func Marshal(v interface{}) ([]byte, error) // json编码
  func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error) // json编码带缩进
  func Unmarshal(data []byte, v interface{}) error // json解码
  package main import ( &amp;#34;fmt&amp;#34; // &amp;#34;reflect&amp;#34;  &amp;#34;encoding/json&amp;#34; ) type User struct{ // Name string `json:&amp;#34;-,&amp;#34;` // 这个导出才是 {&amp;#34;-&amp;#34;:&amp;#34;张三&amp;#34;,&amp;#34;age&amp;#34;:20}  // Name string `json:&amp;#34;-&amp;#34;` // always omitted  // Name string `json:&amp;#34;,omitempty&amp;#34;` // 如果为零值导出为空. 然而不想重命名.</description>
    </item>
    
    <item>
      <title>Sort</title>
      <link>https://liuzeng01.github.io/programing/go/note/july/sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/note/july/sort/</guid>
      <description>实现Go提供的sort接口，来进行自定义排序  只需要实现下列三个接口，就可以进行排序
 package sort type Interface interface { Len() int // 获取元素数量  Less(i, j int) bool // i，j是序列元素的指数。  Swap(i, j int) // 交换元素 } 自己模拟了一个最简单的示例
package mainimport (&amp;quot;fmt&amp;quot;&amp;quot;sort&amp;quot;)func main() {var mysort MySortvar a SortTypea.id = 5a.Name = &amp;quot;a&amp;quot;var b SortTypeb.id = 51b.Name = &amp;quot;b&amp;quot;var c SortTypec.id = 6c.Name = &amp;quot;c&amp;quot;var d SortTyped.</description>
    </item>
    
    <item>
      <title>SRE介绍</title>
      <link>https://liuzeng01.github.io/booknote/sre/sre%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/booknote/sre/sre%E4%BB%8B%E7%BB%8D/</guid>
      <description> SRESRE是指Site Reliability Engineer (网站可靠性工程师)。他是软件工程师和系统管理员的结合，一个SRE工程师基本上需要掌握很多知识：算法，数据结构，编程能力，网络编程，分布式系统，可扩展架构，故障排除。SRE都干些什么？ SRE不是做底层硬件维护，而是负责各种服务的性能和稳定性。远离底层硬件，更多靠近软件基础架构层面，帮助企业客户打造强大的软件基础构架。 Back</description>
    </item>
    
    <item>
      <title>SSH</title>
      <link>https://liuzeng01.github.io/programing/go/note/july/ssh/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/note/july/ssh/</guid>
      <description>利用Go语言提供的ssh包实现一个ssh工具 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net&amp;#34; &amp;#34;os&amp;#34; &amp;#34;time&amp;#34; &amp;#34;golang.org/x/crypto/ssh&amp;#34; ) func main() { session, err := connect(&amp;#34;root&amp;#34;, &amp;#34;abc@123A&amp;#34;, &amp;#34;10.45.11.115&amp;#34;, 22) if err != nil { log.Fatal(err) } defer session.Close() fmt.Printf(&amp;#34;----&amp;gt;&amp;#34;) session.Stdout = os.Stdout session.Stderr = os.Stderr session.Stdin = os.Stdin session.Run(&amp;#34;sh&amp;#34;) } func connect(user, password, host string, port int) (*ssh.Session, error) { var ( addr string clientConfig *ssh.ClientConfig client *ssh.Client session *ssh.Session err error ) clientConfig = &amp;amp;ssh.ClientConfig{ User: user, Auth: []ssh.</description>
    </item>
    
    <item>
      <title>viper</title>
      <link>https://liuzeng01.github.io/programing/go/github.com/spf13/viper/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/github.com/spf13/viper/</guid>
      <description>1. 介绍  Viper是Go应用程序的完整配置解决方案，包括12-Factor应用程序。它旨在在应用程序中工作，并可以处理所有类型的配置需求和格式。它支持：
 设置默认值从JSON，TOML，YAML，HCL和Java属性配置文件中读取实时观看和重新读取配置文件（可选）从环境变量中读取从远程配置系统（etcd或Consul）读取，并观察变化从命令行标志读取从缓冲区读取设置显式值 Viper可以被认为是所有应用程序配置需求的注册表。
在构建现代应用程序时，您不必担心配置文件格式; 你可以专注于构建出色的软件。 Viper 可以做如下工作：
 加载并解析JSON、TOML、YAML、HCL 或 Java properties 格式的配置文件可以为各种配置项设置默认值可以在命令行中指定配置项来覆盖配置值提供了别名系统，可以不破坏现有代码来实现参数重命名可以很容易地分辨出用户提供的命令行参数或配置文件与默认相同的区别 Viper读取配置信息的优先级顺序，从高到低，如下：
 显式调用Set函数命令行参数环境变量配置文件key/value 存储系统默认值 Viper 的配置项的key不区分大小写。
2. 使用示例  1. 配置文件示例 internal.toml,配置数据库的连接信息 [DataBase] DBType = &amp;#34;mysql&amp;#34; Host = &amp;#34;127.0.0.1:3306&amp;#34; Username = &amp;#34;golang&amp;#34; Password = &amp;#34;golang&amp;#34; Charset = &amp;#34;utf8&amp;#34; 2. 声明数据库连接对象 type DBModel struct { Engine *sql.</description>
    </item>
    
    <item>
      <title>动态规划</title>
      <link>https://liuzeng01.github.io/booknote/algorithm/dynamic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/booknote/algorithm/dynamic/</guid>
      <description> 1.实例说明什么是动态规划 计算1到10的和 计算过程：1+2+3+4+5+6+7+8+9+10，得55
上述如果口算，最快也要前后凑整10的相加，就是需要计算所有的值，才能得出结果。这时候，如果再加一个11，你肯定会脱口而出，得66，为什么直接能说出来呢，因为你记住了前面所求的得和，这一次得计算不需要关心前面这个55怎么来得，只关注这一步即可。
引出定义：（有点难理解）在现实生活中，有一类活动的过程，由于它的特殊性，可将过程分成若干个互相联系的阶段，在它的每一阶段都需要作出决策，从而使整个过程达到最好的活动效果。因此各个阶段决策的选取不能任意确定，它依赖于当前面临的状态，又影响以后的发展。当各个阶段决策确定后，就组成一个决策序列，因而也就确定了整个过程的一条活动路线．这种把一个问题看作是一个前后关联具有链状结构的多阶段过程就称为多阶段决策过程，这种问题称为多阶段决策问题。在多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化的过程为动态规划方法。
优化理解：动态规划是把一个大问题拆解成一堆小问题，这个本身没什么问题，但是核心不是能拆分，而是取决于该问题拆分出的小问题是否能被特定的规律重复利用。  2. 实际问题解决例子：路径最小值问题 给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点
例如，给定三角形： [ [2], [3,4], [6,5,7], [4,1,8,3] ] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
过程解析：自上而下计算时，只要每一步都记录路径上最小的值即可，因为路径上只能访问相邻的两个点，所以比较两个相邻点和本点数据的和，保存较小的一个值即可。不断向下类推，最后一组数据中最小的值就是i最小路径。
func minimumTotal(triangle [][]int) int { for i, v := range triangle { if i == 0 {//第一层没有上一级，不用计算  continue } for idx, val := range v { if idx == len(v)-1 {//最后一个值,他的上一级比他小一位数,所以相邻点只有一个直接赋值  triangle[i][idx] = val + triangle[i-1][idx-1] continue } if idx == 0 {//第一位，相邻点也只有一个，直接赋值  triangle[i][idx] = val + triangle[i-1][idx] continue } if val+triangle[i-1][idx] &amp;gt; val+triangle[i-1][idx-1] {// 比较相邻点较小值，并记录  triangle[i][idx] = val + triangle[i-1][idx-1]// 不需要原来的值,直接赋值保存即可,因为只关心路径结果即可  } else { triangle[i][idx] = val + triangle[i-1][idx] } } } min := triangle[len(triangle)-1][0] for _, v := range triangle[len(triangle)-1] {//最后一组中最小值就是路径最小  if v &amp;lt; min { min = v } } return min }  Back</description>
    </item>
    
    <item>
      <title>文件操作</title>
      <link>https://liuzeng01.github.io/programing/go/note/july/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/note/july/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</guid>
      <description>1.打开关闭文件 file open/close
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) func main() { // 只读方式打开当前目录下的main.go文件 	file, err := os.Open(&amp;#34;./main.go&amp;#34;) if err != nil { fmt.Println(&amp;#34;open file failed!, err:&amp;#34;, err) return } // 关闭文件 	file.Close() } 2.文件读取 file read 它接收一个字节切片，返回读取的字节数和可能的具体错误，读到文件末尾时会返回0和io.EOF
func (f *File) Read(b []byte) (n int, err error) func main() { // 只读方式打开当前目录下的main.go文件 	file, err := os.Open(&amp;#34;./main.go&amp;#34;) if err != nil { fmt.Println(&amp;#34;open file failed!, err:&amp;#34;, err) return } defer file.</description>
    </item>
    
    <item>
      <title>PCRF Application </title>
      <link>https://liuzeng01.github.io/zsmart/pcrf/structrue/application/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/zsmart/pcrf/structrue/application/</guid>
      <description>  Back</description>
    </item>
    
    <item>
      <title>routine</title>
      <link>https://liuzeng01.github.io/programing/go/github.com/x-mod/routine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/github.com/x-mod/routine/</guid>
      <description>github.com/x-mod/routine  为什么要写这么一个基础库呢？
  每段程序都是从 main 函数开始的，但是，却不会将整个程序的功能实现都放在 main 函数里。而是，通过层层功能的抽象与封装，最终，在 main 函数仅提供功能函数的入口。所以，当我们看很多大型程序时，其实，main 函数是非常简单的。
  但是，即使 main 函数越变越简单，有些必要的功能则是逃不掉的。例如程序启动参数、程序的信号处理，这些通常还是会放在 main 函数进行处理。
  除了以上 main 函数本身的处理以外，我发现将程序中的执行绪，也就是固定的 Go 协程的入口放在 main 函数中进行定义，可以帮助维护者更加快速的理解应用的逻辑实现。
 link 使用方法 import &amp;#34;github.com/x-mod/routine&amp;#34; //timeout timeout := routine.Timeout(time.Minute, exec) //retry retry := routine.Retry(3, exec) //repeat repeat := routine.Repeat(10, time.Second, exec) //concurrent concurrent := routine.Concurrent(4, exec) //schedule executor crontab := routine.Crontab(&amp;#34;* * * * *&amp;#34;, exec) //command command := routine.Command(&amp;#34;echo&amp;#34;, routine.ARG(&amp;#34;hello routine!</description>
    </item>
    
    <item>
      <title>网络相关</title>
      <link>https://liuzeng01.github.io/essay/july/net/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/essay/july/net/</guid>
      <description>1. 网络结构 因特网服务提供商 ISP（Internet Service Provider） 不同的ISP根据其规模大小被拆分为不同层次，覆盖面积最广的就是主干ISP，通常为国家级范围，其次是地区，借助一个或多个主干并联，最后是本地ISP，可以直接连主干，也可以连地区，也就是我们最常用的（比如公司内网私有云、学校、公有云厂商）
任何一个ISP(除了顶层)都可以和多个ISP互联，成为他们的下级，也就是多宿（multi-home）, 这时候即使提供商之一出现问题，他仍然不会断网
用户那么多，主干ISP就那么几个，肯定要涵盖超大的网络数据流量，就算他有最大的带宽，可以完成流量交换，但是距离越远传输速度越慢是亘古不变的真理，如果先把相邻地区流量转发到千里之外再转发回来，是一种对网络资源的浪费
为了避免这种浪费，一种更有效快速的转发方式出现了，那就是因特网交换点 IXP （Internet Exchange Point）
这个时候BAT在干嘛呢？BAT 严格意义上来说不属于ISP，他们是提供内容的，所以被叫做因特网内容提供商 ICP（Internet Content Provider），内容供应商有内容，他们的数据中心需要和运营商网络互联互通，才能被他们的用户访问。
一般是拉通了专线边界网关协议 BGP（Border Gateway Protocol），简单来说你向BAT发消息，他们就近原则回消息，根据你访问的源地址，判断消息从哪里过来的，如果是电信，就走电信的线路回去。如果是联通，就走联通的线路回去。
以前互联网数据中心 IDC（Internet Data Center）都是运营商的，为了让自己的服务跑的更快，现在是 BAT都自建数据中心，也就是云，多余的计算资源也向外提供，把计算放到云上，这就是云计算.
再结合一个叫软件定义网络 SDN（Software Defined Network）的东西，特别是可编程路由，使得路由可以根据业务需求，流量需求，怎么省钱怎么来，用他来充当IXP的角色，成本比路由器还要便宜，而且可以按需调度，可以支持复杂流量工程，以实现分布式拒绝服务（DDOS）防止被攻击。
2. 网络协议 网络协议类似于人类协议，只不过把对话的人换成了某些硬件和软件设备（例如计算机、手机、路由器），他们之间使用的都是同一种语言（byte 流，最终解析成电信号），严格受协议的制约。
  硬件直接通过网线互联，通过协议控制网卡之间的比特流
  端系统通过阻塞控制协议，控制收发包过程中分组发送速率
  路由器协议，控制分组从源到目的地之间的路径
  七层协议 从第七层到第一层，分别对应了不同的一个数据包（报文）在不同解决的不同处理办法（协议），每个报文在传输出去的时候会经历打包的过程，套七层外套，在接收和传递的时候会经历拆包的过程，脱下七层衣服。
每一层都会携带一些关键信息给对应的设备识别，为了保证输出包顺利的投递，在传输过程中会经历很多设备，也会经历很多次拆包打包。
交换机和路由器的区别就是，路由器在网络层，可以处理TCP/IP协议，可以把一个IP分配给多个主机而交换机不能，交换机在链路层是根据MAC寻址，可以提供防火墙功能而路由器不能。路由器主要用来连接多个网络，交换机主要用来使局域网连接更多计算机。
常见家用交换机是指二层交换机，现在有三层及三层以上的交换机可基于网络层甚至传输层工作。
没有提到会话层和表示层，我个人的理解这两层从来没有独立实现过，都是和应用层在一起实现。一般的程序员都是在应用层编程，应用层主要加入了会话保持、断点下载能力，表示层主要是做数据加密解密压缩以及转码（虚拟终端协议 VTP，定义了统一的字符集、终端命令、格式控制符等等）的工作，比如大部分主机使用ASCII码，IBM 主机使用 EBCDIC 编码
有一个安全加密层，很多人都使用过，只是一直没有人想去划分层次结构，它的名字叫SSL/TLS，有了安全层提供的服务，位于应用层的HTTP/SMTP/FTP，都可以在其名字后加一个S（Security），比如HTTPS，其实这个世界压根不存在HTTPS协议，只有HTTP协议，加上 S 的后缀只是告诉大家HTTP使用的是六层结构，有了SSL/TLS的安全保护。
网络延迟丢包 为什么高峰期就会卡，不应该是我独享的宽带吗？事实上是共享的，在介绍为什么共享之前，先介绍下传输过程中产生的速度损耗。
还是让我们回到最常用的分组交换，分组交换我们说过，他把报文切片，变成一个一个的数据包进行传输，在传输给分组交换机的时候，交换机本身会进行一些包检查，这里浪费的时间叫节点处理时延（nodal processing delay）
多数分组交换机在链路的输入端使用存储转发传输（store-and-forward transmission）机制，在交换机输出该分组的第一个比特之前，必须接收到整个分组，这个等待的时间叫存储转发时延</description>
    </item>
    
    <item>
      <title>cobra</title>
      <link>https://liuzeng01.github.io/programing/go/github.com/spf13/cobra/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/github.com/spf13/cobra/</guid>
      <description>cobraCobra 是一个用来创建命令行的 golang 库，同时也是一个用于生成应用和命令行文件的程序, 包括docker，k8s 都用的类似方式去实现，用于实现CLI非常好用可提供的功能点  简易的子命令行模式，如 app server， app fetch等等 完全兼容posix命令行模式 嵌套子命令subcommand 支持全局，局部，串联flags 使用Cobra很容易的生成应用程序和命令，使用cobra create appname和cobra add cmdname 如果命令输入错误，将提供智能建议，如 app srver，将提示srver没有，是否是app server 自动生成commands和flags的帮助信息 自动生成详细的help信息，如app help 自动识别-h，&amp;ndash;help帮助flag 自动生成应用程序在bash下命令自动完成功能 自动生成应用程序的man手册 命令行别名 自定义help和usage信息 可选的紧密集成的viper apps  安装方法 go get -v github.com/spf13/cobra/cobra
使用方法 1. 新建一个cobra项目 cobra init --pkg-name cobrademo
2. 目录结构 ▾ demo ▾ cmd/ root.go main.go main.go package main import ( &amp;#34;GoStudy/week16/cobrademo/cmd&amp;#34; ) func main() { cmd.</description>
    </item>
    
    <item>
      <title>Core net structrue</title>
      <link>https://liuzeng01.github.io/zsmart/pcrf/corenet/net/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/zsmart/pcrf/corenet/net/</guid>
      <description>  Back</description>
    </item>
    
    <item>
      <title>hugo</title>
      <link>https://liuzeng01.github.io/programing/go/github.com/gohugoio/hugo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/github.com/gohugoio/hugo/</guid>
      <description>DescriptionHugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。 Hugo采用 Go 编程语言开发，Hugo 的设计目标是让创建网站重新变得有趣。Show More Hugo 是一个通用的网站框架。从技术上讲，Hugo 是一个静态站点生成器。与动态构建页面的系统不同，Hugo 在创建或更新内容时构建页面。由于网站的浏览频率远高于编辑频率，因此 Hugo 旨在为您的网站最终用户提供最佳的浏览体验，并为网站作者提供理想的写作体验。使用 Hugo 构建的网站非常快速和安全。Hugo 构建的网站可以托管在任何地方，包括 Netlify、Heroku、GoDaddy、DreamHost、GitHub Pages、GitLab Pages、Surge、Aerobatic、Firebase、Google Cloud Storage、Amazon S3、Rackspace、Azure, 和 CloudFront，并且与 CDN 更配。Hugo 网站在运行时不需要数据库或依赖于诸如 Ruby、Python 或 PHP 等昂贵的运行时环境。我们认为 Hugo 是一个理想的网站创建工具，具有几乎即时的构建时间，能够在网站修改时即刻重建。
1. Hugo 部署   二进制安装（推荐：简单、快速） 到 Hugo Releases 下载对应的操作系统版本的Hugo二进制文件（hugo或者hugo.exe）
  编译部署 熟悉Go语言的朋友可以试下这个方法，不过great wall的存在让依赖不太好下载。不过下载下之后可以自己进行魔改。geek们可以试下。
go get -u -v github.com/spf13/hugo
  开始建立hugo project hugo new site mydocs 建立好之后的目录结构为</description>
    </item>
    
    <item>
      <title>PCRF Backend Process</title>
      <link>https://liuzeng01.github.io/zsmart/pcrf/structrue/process/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/zsmart/pcrf/structrue/process/</guid>
      <description>  Back</description>
    </item>
    
    <item>
      <title>RX流程调测</title>
      <link>https://liuzeng01.github.io/zsmart/pcrf/testcase/rxbasic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/zsmart/pcrf/testcase/rxbasic/</guid>
      <description>  Back</description>
    </item>
    
    <item>
      <title>tran</title>
      <link>https://liuzeng01.github.io/programing/go/note/july/tran/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/note/july/tran/</guid>
      <description>Tran工具 使用了百度翻译的API，进行单词或者短句的翻译 主要是为了方便自己平时写一些英文文档时，词穷的情况。所以设计成了命令行程序，随时使用。   1. 入口模块 利用了cobra来进行设计
main.go package main import &amp;#34;tran/cmd&amp;#34; func main() { cmd.Execute() } //执行入口 cmd/root.go package cmd import ( &amp;#34;GoStudy/week17/tran/internal&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;github.com/spf13/cobra&amp;#34; &amp;#34;os&amp;#34; homedir &amp;#34;github.com/mitchellh/go-homedir&amp;#34; &amp;#34;github.com/spf13/viper&amp;#34; ) var cfgFile string var rootCmd = &amp;amp;cobra.Command{ Use: &amp;#34;tran&amp;#34;, Short: &amp;#34;The applicaiton to help you translate the word in the terminal&amp;#34;, Long: `The Manual method : Input your query string ,and input your target language code, E.</description>
    </item>
    
    <item>
      <title>分阶段构建减小go镜像体积</title>
      <link>https://liuzeng01.github.io/linux/docker/dockerfile/godockerfile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/linux/docker/dockerfile/godockerfile/</guid>
      <description> 分阶段构建主要思路 第一阶段 使用golang镜像构建出可执行文件 第二阶段 使用busybox:glibc小镜像作为基础镜像镜像文件 第一阶段 FROMgolang AS my_build_stageCOPY hello.go .RUN go build hello.go第二阶段 FROMbusybox:glibcCOPY --from=my_build_stage hello .// COPY --from=0 hello . 与COPY --from=my_build_stage hello .等效 0表示第一阶段CMD [&amp;#34;./hello&amp;#34;] Go项目应用的Dockerfile通常大概类似这样，但是每个项目的细节可能有所不同。
FROM golang:alpine指定了开始阶段的基础映像（其中包含Go工具和库，用于构建程序），AS build是给这个阶段取名为build。 golang:alpine指定了Go基础映像的alpine版本， alpine是专门为容器设计的小型Linux发行版。这个Dockerfile中使用了两次FROM指令，第二条FROM scratch行，它告诉Docker从一个全新的，完全空的容器镜像重新开始，然后将上个阶段编译好的程序复制到其中。这个才是我们随后将用于运行的Go应用程序的容器镜像。
scratch镜像是Docker项目预定义的最小的镜像。 Docker用于Go程序的多阶段构建很常见，使用scratch镜像可以节省大量空间，因为我们实际上不需要Go工具或其他任何东西来运行我们的编译好的程序，这可能也是Go在容器时代的一个优势吧。
 Back</description>
    </item>
    
    <item>
      <title>循环读取输入</title>
      <link>https://liuzeng01.github.io/programing/go/note/july/scanner/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/note/july/scanner/</guid>
      <description> 循环读取用户输入 package main import ( &amp;#34;bufio&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) func main() { scanner() } func scanner() { fmt.Printf(&amp;#34;----&amp;gt;&amp;#34;) scanner := bufio.NewScanner(os.Stdin) for scanner.Scan() { fmt.Println(scanner.Text()) fmt.Printf(&amp;#34;----&amp;gt;&amp;#34;) } } </description>
    </item>
    
    <item>
      <title>nutsdb</title>
      <link>https://liuzeng01.github.io/programing/go/github.com/xujiajun/nutsdb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/github.com/xujiajun/nutsdb/</guid>
      <description>DescriptionNutsDB是纯Go语言编写一个简单、高性能、内嵌型、持久化的key-value数据库。
NutsDB支持事务，从v0.2.0之后的版本开始支持ACID的特性，建议使用最新的release版本。v0.2.0之前的版本，保持高性能，没有作sync，但是具备高性能的写（本地测试，百万数据写入达40~50W+/s）。所有的操作都在事务中执行。NutsDB从v0.2.0版本开始支持多种数据结构，如列表(list)、集合(set)、有序集合(sorted set)。从0.4.0版本开始增加自定义配置读写方式、启动时候的文件载入方式、sync是否开启等
github.com/xujiajun/nutsdb  官方文档
1. 安装 go get -u github.com/xujiajun/nutsdb 2. 使用 开启数据库 package main import ( &amp;#34;log&amp;#34; &amp;#34;github.com/xujiajun/nutsdb&amp;#34; ) func main() { opt := nutsdb.DefaultOptions opt.Dir = &amp;#34;/tmp/nutsdb&amp;#34; //这边数据库会自动创建这个目录文件 	db, err := nutsdb.Open(opt) if err != nil { log.Fatal(err) } defer db.Close() ... } 这里的默认配置是
var DefaultOptions = Options{ EntryIdxMode: HintKeyValAndRAMIdxMode, //EntryIdxMode 代表索引entry的模式. EntryIdxMode 包括选项: HintKeyValAndRAMIdxMode 、HintKeyAndRAMIdxMode和 HintBPTSparseIdxMode。其中HintKeyValAndRAMIdxMode 代表纯内存索引模式（key和value都会被cache）。 HintKeyAndRAMIdxMode 代表内存+磁盘的索引模式（只有key被cache）。 HintBPTSparseIdxMode（v0.</description>
    </item>
    
    <item>
      <title>Go数据结构</title>
      <link>https://liuzeng01.github.io/programing/go/note/july/golang%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/note/july/golang%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>golang本质是全局按照值传递的，也就是copy值，那么你必须知道你的内存对象是包含哪些内容，才能清楚掌握你在copy值的时候复制了哪些东西  num bool string array slice map channel interface  package main func main () { var n int64 = 11 //n就是一个8字节的数据块。 var b bool = true //是一个1字节的数据块。  var s string = &amp;#34;test-string-1&amp;#34; //x  var a [3]bool = [3]bool{true, false, true} var sl []int = []int{1,2,3,4} var m map[int]string var c chan int var in interface{} _, _, _, _, _, _, _, _ = n, b, s, a, sl, m, c , in } string类型 (gdb) pt s type = struct string { uint8 *str; int len; } //string类型在go里是一个复合类型，s变量是一个16字节的变量。其中str字段指向字符串存储的地方 //s就是代表了一个16字节的数据块。所以我们每次定义一个string变量，除了字符序列，s的本身结构是分配16个字节在栈上。 数组类型 //数组类型，就是在地址空间中连续的一段内存块，和c一样（旁白：和c一样，都是平坦的内存结构）。 (gdb) p &amp;amp;a $13 = ([3]bool *) 0xc00003070d (gdb) x/6bx 0xc00003070d 0xc00003070d: 0x01 0x00 0x01 0x0b 0x00 0x00 切片类型 // 是个复合类型，变量本身是一个管理结构（和string一样），这个管理结构管理着一段连续的内存 (gdb) pt sl type = struct []int { int *array; int len; int cap; } map 类型 和 channel 类型 map类型和channel类型特别提一点，变量本身本质上是一个指针类型。也就是说上面我们定义了两个变量m，c，从内存分配的角度来讲，只在栈上分配了一个指针变量，并且这个指针还是nil值，所以我们经常看到 go 的一个特殊说明：slice，map，channel 这三种类型必须使用make来创建，就是这个道理。因为如果仅仅定义了类型变量，那仅仅是代表了分配了这个变量本身的内存空间，并且初始化是nil，一旦你直接用，那么就会导致非法地址引用的问题。slice 的24个字节的管理空间，map和channel的一个指针8个字节的空间。那么如果是调用了make，其实就会把下面的结构分配并初始化出来。</description>
    </item>
    
    <item>
      <title>Go语言查询不定字段</title>
      <link>https://liuzeng01.github.io/programing/go/note/july/sqlnodefine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/note/july/sqlnodefine/</guid>
      <description>package main import ( &amp;#34;database/sql&amp;#34; &amp;#34;fmt&amp;#34; _ &amp;#34;github.com/go-sql-driver/mysql&amp;#34; ) func main() { //连接数据库 	db, err := sql.Open(&amp;#34;mysql&amp;#34;, &amp;#34;golang:golang@tcp(localhost:3306)/gostudy?charset=utf8&amp;#34;) if err != nil { fmt.Println(&amp;#34;连接数据库失败&amp;#34;, err.Error()) return } defer db.Close() //查询数据库 	query, err := db.Query(&amp;#34;select * from event_filelist&amp;#34;) if err != nil { fmt.Println(&amp;#34;查询数据库失败&amp;#34;, err.Error()) return } defer query.Close() //读出查询出的列字段名 	cols, _ := query.Columns() //values是每个列的值，这里获取到byte里 	values := make([][]byte, len(cols)) //query.Scan的参数，因为每次查询出来的列是不定长的，用len(cols)定住当次查询的长度 	scans := make([]interface{}, len(cols)) //让每一行数据都填充到[][]byte里面 	for i := range values { scans[i] = &amp;amp;values[i] } //最后得到的map 	results := make(map[int]map[string]string) i := 0 for query.</description>
    </item>
    
    <item>
      <title>IP</title>
      <link>https://liuzeng01.github.io/programing/go/note/july/ip/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/note/july/ip/</guid>
      <description>在cobra里面写了一个IP地址转16进制的脚本，用到了net包 package internal import ( &amp;#34;encoding/hex&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;net&amp;#34; &amp;#34;strings&amp;#34; ) func ParseIPV4(ipaddr string){ if len(ipaddr) == 0 { return } hexaddr := strings.ToUpper(hex.EncodeToString(net.ParseIP(ipaddr).To4())) fmt.Println(hexaddr) } func ParseIPV6(ipaddr string){ if len(ipaddr) == 0 { return } hexaddr := strings.ToUpper(hex.EncodeToString(net.ParseIP(ipaddr).To16())) fmt.Println(hexaddr) } //光有转16进制是不行的，还需要从16进制转回ip地址 func ParseHexToIpv4(hexstring string) { if len(hexstring) == 0 { return } var ip net.IP ip, err := hex.DecodeString(hexstring) if err != nil { fmt.Println(err) return } fmt.Println(ip.To4()) } func ParseHexToIpv6(hexstring string) { if len(hexstring) == 0 { return } var ip net.</description>
    </item>
    
    <item>
      <title>mod</title>
      <link>https://liuzeng01.github.io/programing/go/note/july/mod/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/note/july/mod/</guid>
      <description>modgo mod能管理的依赖包的版本，能保证在不同地方构建，获得的依赖模块是一致的。1. 常用代理地址 https://mirrors.aliyun.com/goproxy/ //阿里云镜像 https://goproxy.io https://goproxy.cn //七牛云镜像 https://athens.azurefd.net //微软镜像 2. 常用命令 * go mod init # 初始化当前目录为模块根目录，生成go.mod, go.sum文件 * go mod download # 下载依赖包 * go mod tidy # 整理检查依赖，如果缺失包会下载或者引用的不需要的包会删除 * go mod vendor # 复制依赖到vendor目录下面 * go mod # 可看完整所有的命令 ## 如果发现编译不过，可以通过下面命令列出指定mod的版本，然后go get拉指定版本号的包 go list -m -versions rsc.io/sampler go get rsc.io/sampler@v1.3.1 补充   用 go get 拉取新的依赖拉取最新的版本(优先择取 tag)：go get golang.</description>
    </item>
    
    <item>
      <title>toml</title>
      <link>https://liuzeng01.github.io/essay/july/toml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/essay/july/toml/</guid>
      <description>TOML是前GitHub CEO， Tom Preston-Werner，于2013年创建的语言，其目标是成为一个小规模的易于使用的语义化配置文件格式。TOML被设计为可以无二义性的转换为一个哈希表(Hash table)。TOML是大小写敏感的，必须是UTF-8编码。
title = &amp;#34;TOML Example&amp;#34; [owner] name = &amp;#34;Lance Uppercut&amp;#34; dob = 1979-05-27T07:32:00-08:00 # 日期是一等公民 [database] server = &amp;#34;192.168.1.1&amp;#34; ports = [ 8001, 8001, 8002 ] connection_max = 5000 enabled = true [servers] #你可以使用空格、制表符进行缩进，或者根本不缩进。TOML不关心缩进。 [servers.alpha] ip = &amp;#34;10.0.0.1&amp;#34; dc = &amp;#34;eqdc10&amp;#34; [servers.beta] ip = &amp;#34;10.0.0.2&amp;#34; dc = &amp;#34;eqdc10&amp;#34; [clients] data = [ [&amp;#34;gamma&amp;#34;, &amp;#34;delta&amp;#34;], [1, 2] ] # 数组内可以混入换行符 hosts = [ &amp;#34;alpha&amp;#34;, &amp;#34;omega&amp;#34; ] 注释 注释使用#开头</description>
    </item>
    
    <item>
      <title>tview</title>
      <link>https://liuzeng01.github.io/programing/go/github.com/rivo/tview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://liuzeng01.github.io/programing/go/github.com/rivo/tview/</guid>
      <description>github.com/rivo/tview 1. 常用的控件    TextView: A scrollable window that display multi-colored text. Text may also be highlighted. Table: A scrollable display of tabular data. Table cells, rows, or columns may also be highlighted. TreeView: A scrollable display for hierarchical data. Tree nodes can be highlighted, collapsed, expanded, and more. List: A navigable text list with optional keyboard shortcuts. InputField: One-line input fields to enter text. DropDown: Drop-down selection fields.</description>
    </item>
    
  </channel>
</rss>