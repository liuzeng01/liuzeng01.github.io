[
{
	"uri": "https://liuzeng01.github.io/programing/go/",
	"title": "Go",
	"tags": [],
	"description": "Golang",
	"content": " Go Daily Note \r\rGo语言第三方库 \r\r\r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/programing/go/daily/",
	"title": "Go Daily Note",
	"tags": [],
	"description": "Daily Note",
	"content": " Json \r\rSort \r\rSSH \r\r文件操作 \r\rGolang 数据结构 \r\r\r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/programing/go/github.com/",
	"title": "Go语言第三方库",
	"tags": [],
	"description": "GitHub上的Go开源库",
	"content": " routine \r\rhugo \r\rnutsdb \r\r\r "
},
{
	"uri": "https://liuzeng01.github.io/essay/july/hugo/",
	"title": "hugo语法",
	"tags": [],
	"description": "Essay",
	"content": " 1. hugo 2. Ace Document   button The button shortcode allows you to add a button to the page. This button is a HTML anchor element and can thus be used to link to another page or website.\n\rButton\r\rButton\r\rButton\r\rButton\r\rButton\r\rButton\r\rButton\r\rUsage Place the following shortcode on the page Copy\r\r\r{{\u0026lt; button style=\u0026#34;STYLE\u0026#34; link=\u0026#34;https://yourwebsite.com\u0026#34; \u0026gt;}} [content] {{\u0026lt; /button \u0026gt;}} \r\r\rParameters style The style parameter is directly applied to the alert as a class in the format \u0026ldquo;btn-{STYLE}\u0026quot;. Bootstrap comes with a variety of styles that can be used with this:\n primary secondary danger warning success info  Each style can also be presented as an \u0026lsquo;outline\u0026rsquo; variant by prefixing the style with \u0026lsquo;outline-\u0026rsquo;.\nExample: style=\u0026quot;outline-primary\u0026quot;.\nlink The link parameter may consist of an URL leading to a page or other website. Simply use it by defining a URL for the button to link to.\nExample: link=\u0026quot;https://google.com\u0026quot;.\n  Alert The alerts shortcode allows you to let information stand out by means of an alert styled box. This can be used to indicate danger, warning, success or info.\n\rI\u0026rsquo;m a danger alert\r\rI\u0026rsquo;m a warning alert\r\rI\u0026rsquo;m a success alert\r\rI\u0026rsquo;m an info alert\r\rUsage Place the following shortcode on the page Copy\r\r\r{{\u0026lt; alert style=\u0026#34;STYLE\u0026#34; \u0026gt;}} [content] {{\u0026lt; /alert \u0026gt;}} \r\r\rParameters Style  danger warning success info     Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/programing/go/daily/json/",
	"title": "Json ",
	"tags": [],
	"description": "Daily Note",
	"content": " Json   func Marshal(v interface{}) ([]byte, error) // json编码\n  func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error) // json编码带缩进\n  func Unmarshal(data []byte, v interface{}) error // json解码\n  package main import ( \u0026#34;fmt\u0026#34; // \u0026#34;reflect\u0026#34;  \u0026#34;encoding/json\u0026#34; ) type User struct{ // Name string `json:\u0026#34;-,\u0026#34;` // 这个导出才是 {\u0026#34;-\u0026#34;:\u0026#34;张三\u0026#34;,\u0026#34;age\u0026#34;:20}  // Name string `json:\u0026#34;-\u0026#34;` // always omitted  // Name string `json:\u0026#34;,omitempty\u0026#34;` // 如果为零值导出为空. 然而不想重命名.  Name string `json:\u0026#34;name,omitempty\u0026#34;` // 如果为零值导出为空.  // Age int `json:\u0026#34;age,string\u0026#34;` // 这个会把int变成json string...  // 上面那个很有用. 在 A map =\u0026gt; string =\u0026gt; B map 的时候可能会被弄成科学计数法..  // 用字符串表示时间戳这种可以避免这个...  Age int `json:\u0026#34;age\u0026#34;` sex int `json:\u0026#34;sex\u0026#34;` } func main() { u := User{\u0026#34;张三\u0026#34;, 20, 1} uu, _ := json.Marshal(u) // 只会导出公有的, 即首字母大写的  fmt.Println(string(uu)) }  Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/essay/july/",
	"title": "July",
	"tags": [],
	"description": "2020 07",
	"content": " hugo语法 \r\r网络相关 \r\r\r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/linux/shell/",
	"title": "Shell",
	"tags": [],
	"description": "Shell",
	"content": " \r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/programing/go/daily/sort/",
	"title": "Sort",
	"tags": [],
	"description": "Daily Note",
	"content": " 实现Go提供的sort接口，来进行自定义排序  只需要实现下列三个接口，就可以进行排序\n package sort type Interface interface { Len() int // 获取元素数量  Less(i, j int) bool // i，j是序列元素的指数。  Swap(i, j int) // 交换元素 } 自己模拟了一个最简单的示例\npackage main\rimport (\r\u0026quot;fmt\u0026quot;\r\u0026quot;sort\u0026quot;\r)\rfunc main() {\rvar mysort MySort\rvar a SortType\ra.id = 5\ra.Name = \u0026quot;a\u0026quot;\rvar b SortType\rb.id = 51\rb.Name = \u0026quot;b\u0026quot;\rvar c SortType\rc.id = 6\rc.Name = \u0026quot;c\u0026quot;\rvar d SortType\rd.id = 1\rd.Name = \u0026quot;d\u0026quot;\rmysort = []SortType{a, b, c, d}\rsort.Sort(mysort)\rfmt.Println(mysort)\r}\rtype MySort []SortType\rtype SortType struct {\rName string\rid int\r}\rfunc (a MySort) Len() int { return len(a) }\rfunc (a MySort) Swap(i, j int) { a[i], a[j] = a[j], a[i] }\rfunc (a MySort) Less(i, j int) bool { return a[i].id \u0026lt; a[j].id }\r//输出结果为\r[{d 1} {a 5} {c 6} {b 51}]\r 接口实现不受限于结构体，任何类型都可以实现接口。但是系统自定义的类型是无法实现的，因为GO语言自己实现了这些[]int ,[]string 的接口。如果要自己实现自定义的排序的话，可以添加别名类型。\n  Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/booknote/sre/",
	"title": "SRE",
	"tags": [],
	"description": "SRE",
	"content": " SRE介绍 \r\r\r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/booknote/sre/sre%E4%BB%8B%E7%BB%8D/",
	"title": "SRE介绍",
	"tags": [],
	"description": "Note",
	"content": " \rSRE\r\rSRE是指Site Reliability Engineer (网站可靠性工程师)。他是软件工程师和系统管理员的结合，一个SRE工程师基本上需要掌握很多知识：算法，数据结构，编程能力，网络编程，分布式系统，可扩展架构，故障排除。\r\r\r\rSRE都干些什么？ SRE不是做底层硬件维护，而是负责各种服务的性能和稳定性。\r远离底层硬件，更多靠近软件基础架构层面，帮助企业客户打造强大的软件基础构架。\r\r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/programing/go/daily/ssh/",
	"title": "SSH",
	"tags": [],
	"description": "Daily Note",
	"content": " 利用Go语言提供的ssh包实现一个ssh工具 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;os\u0026#34; \u0026#34;time\u0026#34; \u0026#34;golang.org/x/crypto/ssh\u0026#34; ) func main() { session, err := connect(\u0026#34;root\u0026#34;, \u0026#34;abc@123A\u0026#34;, \u0026#34;10.45.11.115\u0026#34;, 22) if err != nil { log.Fatal(err) } defer session.Close() fmt.Printf(\u0026#34;----\u0026gt;\u0026#34;) session.Stdout = os.Stdout session.Stderr = os.Stderr session.Stdin = os.Stdin session.Run(\u0026#34;sh\u0026#34;) } func connect(user, password, host string, port int) (*ssh.Session, error) { var ( addr string clientConfig *ssh.ClientConfig client *ssh.Client session *ssh.Session err error ) clientConfig = \u0026amp;ssh.ClientConfig{ User: user, Auth: []ssh.AuthMethod{ ssh.Password(password), }, Timeout: 30 * time.Second, HostKeyCallback: func(hostname string, remote net.Addr, key ssh.PublicKey) error { return nil }, } // connet to ssh \taddr = fmt.Sprintf(\u0026#34;%s:%d\u0026#34;, host, port) if client, err = ssh.Dial(\u0026#34;tcp\u0026#34;, addr, clientConfig); err != nil { return nil, err } // create session \tif session, err = client.NewSession(); err != nil { return nil, err } return session, nil }  需要补充的：包装下os.Stdin接口，加入点显示什么的 ssh用来执行远程批量任务比较好。这个先写下来，回头实现下。 解决下windows下os.Stdin结束的行尾存在\u0026rsquo;\\r\\n\u0026rsquo;问题\n  Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/programing/go/daily/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/",
	"title": "文件操作",
	"tags": [],
	"description": "Note",
	"content": " 1.打开关闭文件 file open/close\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { // 只读方式打开当前目录下的main.go文件 \tfile, err := os.Open(\u0026#34;./main.go\u0026#34;) if err != nil { fmt.Println(\u0026#34;open file failed!, err:\u0026#34;, err) return } // 关闭文件 \tfile.Close() } 2.文件读取 file read 它接收一个字节切片，返回读取的字节数和可能的具体错误，读到文件末尾时会返回0和io.EOF\nfunc (f *File) Read(b []byte) (n int, err error) func main() { // 只读方式打开当前目录下的main.go文件 \tfile, err := os.Open(\u0026#34;./main.go\u0026#34;) if err != nil { fmt.Println(\u0026#34;open file failed!, err:\u0026#34;, err) return } defer file.Close() // 使用Read方法读取数据 \tvar tmp = make([]byte, 128) n, err := file.Read(tmp) if err == io.EOF { fmt.Println(\u0026#34;文件读完了\u0026#34;) return } if err != nil { fmt.Println(\u0026#34;read file failed, err:\u0026#34;, err) return } fmt.Printf(\u0026#34;读取了%d字节数据\\n\u0026#34;, n) fmt.Println(string(tmp[:n])) } 3.使用for循环读取文件中的所有数据。 func main() { // 只读方式打开当前目录下的main.go文件 \tfile, err := os.Open(\u0026#34;./main.go\u0026#34;) if err != nil { fmt.Println(\u0026#34;open file failed!, err:\u0026#34;, err) return } defer file.Close() // 循环读取文件 \tvar content []byte var tmp = make([]byte, 128) for { n, err := file.Read(tmp) if err == io.EOF { fmt.Println(\u0026#34;文件读完了\u0026#34;) break } if err != nil { fmt.Println(\u0026#34;read file failed, err:\u0026#34;, err) return } content = append(content, tmp[:n]...) } fmt.Println(string(content)) } 4.bufio  可以用来配合channel使用读取大文件\n package main import ( \u0026#34;bufio\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; ) // bufio按行读取示例 func main() { file, err := os.Open(\u0026#34;./xx.txt\u0026#34;) if err != nil { fmt.Println(\u0026#34;open file failed, err:\u0026#34;, err) return } defer file.Close() reader := bufio.NewReader(file) for { line, err := reader.ReadString(\u0026#39;\\n\u0026#39;) //注意是字符 \tif err == io.EOF { if len(line) != 0 { fmt.Println(line) } fmt.Println(\u0026#34;文件读完了\u0026#34;) break } if err != nil { fmt.Println(\u0026#34;read file failed, err:\u0026#34;, err) return } fmt.Print(line) } } 5.ioutil 读取整个文件 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; ) // ioutil.ReadFile读取整个文件 func main() { content, err := ioutil.ReadFile(\u0026#34;./main.go\u0026#34;) if err != nil { fmt.Println(\u0026#34;read file failed, err:\u0026#34;, err) return } fmt.Println(string(content)) } 6.文件写入操作  os.OpenFile()函数能够以指定模式打开文件，从而实现文件写入相关功能。 func OpenFile(name string, flag int, perm FileMode) (*File, error) {\r...\r}\n name：要打开的文件名 flag：打开文件的模式。 模式有以下几种：\n    模式 含义      os.O_WRONLY 只写    os.O_CREATE 创建文件    os.O_RDONLY 只读    os.O_RDWR 读写    os.O_TRUNC 清空    os.O_APPEND 追加      perm：文件权限，一个八进制数。r（读）04，w（写）02，x（执行）01。\n 7.Write和WriteString func main() { file, err := os.OpenFile(\u0026#34;xx.txt\u0026#34;, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666) if err != nil { fmt.Println(\u0026#34;open file failed, err:\u0026#34;, err) return } defer file.Close() str := \u0026#34;hello 沙河\u0026#34; file.Write([]byte(str)) //写入字节切片数据 \tfile.WriteString(\u0026#34;hello 小王子\u0026#34;) //直接写入字符串数据 }  bufio.NewWriter\n func main() { file, err := os.OpenFile(\u0026#34;xx.txt\u0026#34;, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666) if err != nil { fmt.Println(\u0026#34;open file failed, err:\u0026#34;, err) return } defer file.Close() writer := bufio.NewWriter(file) for i := 0; i \u0026lt; 10; i++ { writer.WriteString(\u0026#34;hello沙河\\n\u0026#34;) //将数据先写入缓存 \t} writer.Flush() //将缓存中的内容写入文件 }  ioutil.WriteFile\n func main() { str := \u0026#34;hello 沙河\u0026#34; err := ioutil.WriteFile(\u0026#34;./xx.txt\u0026#34;, []byte(str), 0666) if err != nil { fmt.Println(\u0026#34;write file failed, err:\u0026#34;, err) return } } 8.copyFile 借助io.Copy()实现一个拷贝文件函数。\n// CopyFile 拷贝文件函数 func CopyFile(dstName, srcName string) (written int64, err error) { // 以读方式打开源文件 \tsrc, err := os.Open(srcName) if err != nil { fmt.Printf(\u0026#34;open %s failed, err:%v.\\n\u0026#34;, srcName, err) return } defer src.Close() // 以写|创建的方式打开目标文件 \tdst, err := os.OpenFile(dstName, os.O_WRONLY|os.O_CREATE, 0644) if err != nil { fmt.Printf(\u0026#34;open %s failed, err:%v.\\n\u0026#34;, dstName, err) return } defer dst.Close() return io.Copy(dst, src) //调用io.Copy()拷贝内容 } func main() { _, err := CopyFile(\u0026#34;dst.txt\u0026#34;, \u0026#34;src.txt\u0026#34;) if err != nil { fmt.Println(\u0026#34;copy file failed, err:\u0026#34;, err) return } fmt.Println(\u0026#34;copy done!\u0026#34;) }  实现一个cat命令 使用文件操作相关知识，模拟实现linux平台cat命令的功能。\n package main import ( \u0026#34;bufio\u0026#34; \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; ) // cat命令实现 func cat(r *bufio.Reader) { for { buf, err := r.ReadBytes(\u0026#39;\\n\u0026#39;) //注意是字符 \tif err == io.EOF { break } fmt.Fprintf(os.Stdout, \u0026#34;%s\u0026#34;, buf) } } func main() { flag.Parse() // 解析命令行参数 \tif flag.NArg() == 0 { // 如果没有参数默认从标准输入读取内容 \tcat(bufio.NewReader(os.Stdin)) } // 依次读取每个指定文件的内容并打印到终端 \tfor i := 0; i \u0026lt; flag.NArg(); i++ { f, err := os.Open(flag.Arg(i)) if err != nil { fmt.Fprintf(os.Stdout, \u0026#34;reading from %s failed, err:%v\\n\u0026#34;, flag.Arg(i), err) continue } cat(bufio.NewReader(f)) } }  Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/linux/",
	"title": "Linux",
	"tags": [],
	"description": "Linux Daily",
	"content": " Shell \r\rRedis \r\rDocker \r\rKernel \r\rOpenStack \r\rKubernetes \r\r\r"
},
{
	"uri": "https://liuzeng01.github.io/linux/redis/",
	"title": "Redis",
	"tags": [],
	"description": "Redis",
	"content": " \r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/programing/go/github.com/x-mod/routine/",
	"title": "routine",
	"tags": [],
	"description": "github.com/x-mod/routine",
	"content": "github.com/x-mod/routine  为什么要写这么一个基础库呢？\n  每段程序都是从 main 函数开始的，但是，却不会将整个程序的功能实现都放在 main 函数里。而是，通过层层功能的抽象与封装，最终，在 main 函数仅提供功能函数的入口。所以，当我们看很多大型程序时，其实，main 函数是非常简单的。\n  但是，即使 main 函数越变越简单，有些必要的功能则是逃不掉的。例如程序启动参数、程序的信号处理，这些通常还是会放在 main 函数进行处理。\n  除了以上 main 函数本身的处理以外，我发现将程序中的执行绪，也就是固定的 Go 协程的入口放在 main 函数中进行定义，可以帮助维护者更加快速的理解应用的逻辑实现。\n link 使用方法 import \u0026#34;github.com/x-mod/routine\u0026#34; //timeout timeout := routine.Timeout(time.Minute, exec) //retry retry := routine.Retry(3, exec) //repeat repeat := routine.Repeat(10, time.Second, exec) //concurrent concurrent := routine.Concurrent(4, exec) //schedule executor crontab := routine.Crontab(\u0026#34;* * * * *\u0026#34;, exec) //command command := routine.Command(\u0026#34;echo\u0026#34;, routine.ARG(\u0026#34;hello routine!\u0026#34;)) //parallel parallel := routine.Parallel(exec1, exec2, exec3, ...) //sequence sequece := routine.Append(exec1, exec2, exec3, ...)  github上提供的示例程序\n package main import ( \u0026#34;context\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;syscall\u0026#34; \u0026#34;time\u0026#34; _ \u0026#34;net/http/pprof\u0026#34; \u0026#34;runtime/trace\u0026#34; \u0026#34;github.com/x-mod/routine\u0026#34; ) func prepare(ctx context.Context) error { log.Println(\u0026#34;prepare begin\u0026#34;) defer log.Println(\u0026#34;prepare end\u0026#34;) trace.Logf(ctx, \u0026#34;prepare\u0026#34;, \u0026#34;prepare ... ok\u0026#34;) return nil } func cleanup(ctx context.Context) error { log.Println(\u0026#34;cleanup begin\u0026#34;) defer log.Println(\u0026#34;cleanup end\u0026#34;) time.Sleep(time.Millisecond * 50) trace.Logf(ctx, \u0026#34;cleanup\u0026#34;, \u0026#34;cleanup ... ok\u0026#34;) return nil } func foo(ctx context.Context) error { log.Println(\u0026#34;foo begin\u0026#34;) defer log.Println(\u0026#34;foo end\u0026#34;) time.Sleep(time.Second * 2) trace.Logf(ctx, \u0026#34;foo\u0026#34;, \u0026#34;sleeping 2s done\u0026#34;) return nil } func bar(ctx context.Context) error { log.Println(\u0026#34;bar begin\u0026#34;) defer log.Println(\u0026#34;bar end\u0026#34;) for i := 0; i \u0026lt; 10; i++ { log.Println(i) trace.Logf(ctx, \u0026#34;bar\u0026#34;, \u0026#34;counting ... %d\u0026#34;, i) } return nil } func main() { f, err := os.Create(\u0026#34;trace.out\u0026#34;) if err != nil { log.Fatalf(\u0026#34;failed to create trace output file: %v\u0026#34;, err) } defer func() { if err := f.Close(); err != nil { log.Fatalf(\u0026#34;failed to close trace file: %v\u0026#34;, err) } }() if err := routine.Main( context.TODO(), routine.ExecutorFunc(bar), routine.Signal(syscall.SIGINT, routine.SigHandler(func() { os.Exit(1) })), routine.Prepare(routine.ExecutorFunc(prepare)), routine.Cleanup(routine.ExecutorFunc(cleanup)), routine.Trace(f), routine.Go(routine.ExecutorFunc(foo)), routine.Go(routine.ExecutorFunc(foo)), routine.Go(routine.ExecutorFunc(foo)), ); err != nil { log.Println(err) } }  接下来是自己的一些模仿实现\n package main import ( \u0026#34;context\u0026#34; \u0026#34;time\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/x-mod/routine\u0026#34; ) func main() { err := routine.Main( context.TODO(), routine.ExecutorFunc(bar), //main协程入口 \troutine.Prepare(routine.ExecutorFunc(prepare)), //启动开始前的准备函数 \troutine.Cleanup(routine.ExecutorFunc(exitclean)), //启动关闭后的清理函数 \troutine.Go(routine.ExecutorFunc(dosomething)), //启动并发的协程 \troutine.Go(routine.Concurrent(5, routine.ExecutorFunc(conexec))), //启动并发执行同一程序 \t//routine.Go(routine.Crontab(\u0026#34;*/1 * * * *\u0026#34;, routine.ExecutorFunc(crontabexec))), //定时执行任务，配置crontab表达式 \troutine.Go(routine.Repeat(3, time.Second, routine.ExecutorFunc(repeatexec))), //定时重复执行一项程序 \t//routine.Go(routine.Deadline(time.Now().Add(5*time.Second), routine.ExecutorFunc(deadlinexec))),这个没搞明白 \t) if err != nil { fmt.Println(err) } } func bar(ctx context.Context) error { fmt.Println(\u0026#34;bar begin\u0026#34;) fmt.Println(time.Now()) defer fmt.Println(\u0026#34;bar end\u0026#34;) return nil } func prepare(ctx context.Context) error { fmt.Println(\u0026#34;Start Prepare !!\u0026#34;) defer fmt.Println(\u0026#34;Prepare finish !!\u0026#34;) return nil } func exitclean(ctx context.Context) error { fmt.Println(\u0026#34;Exiting !!\u0026#34;) defer fmt.Println(\u0026#34;Exited\u0026#34;) return nil } func dosomething(ctx context.Context) error { routine.New(routine.ExecutorFunc(bar)).Execute(ctx) //启动新的协程 \ttime.Sleep(50 * time.Millisecond) fmt.Println(time.Now()) return nil } func conexec(ctx context.Context) error { fmt.Println(\u0026#34;并发执行中！！！\u0026#34;) return nil } func crontabexec(ctx context.Context) error { fmt.Println(\u0026#34;定时执行中 ~~~\u0026#34;) return nil } func repeatexec(ctx context.Context) error { fmt.Println(\u0026#34;重复执行中，每隔一秒执行一次\u0026#34;) return nil } func deadlinexec(ctx context.Context) error { for i := 0; i \u0026lt; 10; i++ { fmt.Printf(\u0026#34;等待deadline。。。,%d 秒\\n\u0026#34;, i) time.Sleep(time.Second) } return nil }   image title   总结  这个库包装了所有常见的需要goroutine操作的情景，可以支持并发，串行，重复执行，重试，定时执行，启动新协程等一系列常用的Go并发场景，以后多包装使用这个库，能剩下不少的事情   \u0026ndash;\n"
},
{
	"uri": "https://liuzeng01.github.io/programing/sql/",
	"title": "SQL",
	"tags": [],
	"description": "SQL",
	"content": " \r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/essay/july/net/",
	"title": "网络相关",
	"tags": [],
	"description": "daily note",
	"content": "  1. 网络结构 因特网服务提供商 ISP（Internet Service Provider） 不同的ISP根据其规模大小被拆分为不同层次，覆盖面积最广的就是主干ISP，通常为国家级范围，其次是地区，借助一个或多个主干并联，最后是本地ISP，可以直接连主干，也可以连地区，也就是我们最常用的（比如公司内网私有云、学校、公有云厂商）\n任何一个ISP(除了顶层)都可以和多个ISP互联，成为他们的下级，也就是多宿（multi-home）, 这时候即使提供商之一出现问题，他仍然不会断网\n用户那么多，主干ISP就那么几个，肯定要涵盖超大的网络数据流量，就算他有最大的带宽，可以完成流量交换，但是距离越远传输速度越慢是亘古不变的真理，如果先把相邻地区流量转发到千里之外再转发回来，是一种对网络资源的浪费\n为了避免这种浪费，一种更有效快速的转发方式出现了，那就是因特网交换点 IXP （Internet Exchange Point）\n这个时候BAT在干嘛呢？BAT 严格意义上来说不属于ISP，他们是提供内容的，所以被叫做因特网内容提供商 ICP（Internet Content Provider），内容供应商有内容，他们的数据中心需要和运营商网络互联互通，才能被他们的用户访问。\n一般是拉通了专线边界网关协议 BGP（Border Gateway Protocol），简单来说你向BAT发消息，他们就近原则回消息，根据你访问的源地址，判断消息从哪里过来的，如果是电信，就走电信的线路回去。如果是联通，就走联通的线路回去。\n以前互联网数据中心 IDC（Internet Data Center）都是运营商的，为了让自己的服务跑的更快，现在是 BAT都自建数据中心，也就是云，多余的计算资源也向外提供，把计算放到云上，这就是云计算.\n再结合一个叫软件定义网络 SDN（Software Defined Network）的东西，特别是可编程路由，使得路由可以根据业务需求，流量需求，怎么省钱怎么来，用他来充当IXP的角色，成本比路由器还要便宜，而且可以按需调度，可以支持复杂流量工程，以实现分布式拒绝服务（DDOS）防止被攻击。\n2. 网络协议 网络协议类似于人类协议，只不过把对话的人换成了某些硬件和软件设备（例如计算机、手机、路由器），他们之间使用的都是同一种语言（byte 流，最终解析成电信号），严格受协议的制约。\n  硬件直接通过网线互联，通过协议控制网卡之间的比特流\n  端系统通过阻塞控制协议，控制收发包过程中分组发送速率\n  路由器协议，控制分组从源到目的地之间的路径\n  七层协议 从第七层到第一层，分别对应了不同的一个数据包（报文）在不同解决的不同处理办法（协议），每个报文在传输出去的时候会经历打包的过程，套七层外套，在接收和传递的时候会经历拆包的过程，脱下七层衣服。\n每一层都会携带一些关键信息给对应的设备识别，为了保证输出包顺利的投递，在传输过程中会经历很多设备，也会经历很多次拆包打包。\n交换机和路由器的区别就是，路由器在网络层，可以处理TCP/IP协议，可以把一个IP分配给多个主机而交换机不能，交换机在链路层是根据MAC寻址，可以提供防火墙功能而路由器不能。路由器主要用来连接多个网络，交换机主要用来使局域网连接更多计算机。\n常见家用交换机是指二层交换机，现在有三层及三层以上的交换机可基于网络层甚至传输层工作。\n没有提到会话层和表示层，我个人的理解这两层从来没有独立实现过，都是和应用层在一起实现。一般的程序员都是在应用层编程，应用层主要加入了会话保持、断点下载能力，表示层主要是做数据加密解密压缩以及转码（虚拟终端协议 VTP，定义了统一的字符集、终端命令、格式控制符等等）的工作，比如大部分主机使用ASCII码，IBM 主机使用 EBCDIC 编码\n有一个安全加密层，很多人都使用过，只是一直没有人想去划分层次结构，它的名字叫SSL/TLS，有了安全层提供的服务，位于应用层的HTTP/SMTP/FTP，都可以在其名字后加一个S（Security），比如HTTPS，其实这个世界压根不存在HTTPS协议，只有HTTP协议，加上 S 的后缀只是告诉大家HTTP使用的是六层结构，有了SSL/TLS的安全保护。\n网络延迟丢包 为什么高峰期就会卡，不应该是我独享的宽带吗？事实上是共享的，在介绍为什么共享之前，先介绍下传输过程中产生的速度损耗。\n还是让我们回到最常用的分组交换，分组交换我们说过，他把报文切片，变成一个一个的数据包进行传输，在传输给分组交换机的时候，交换机本身会进行一些包检查，这里浪费的时间叫节点处理时延（nodal processing delay）\n多数分组交换机在链路的输入端使用存储转发传输（store-and-forward transmission）机制，在交换机输出该分组的第一个比特之前，必须接收到整个分组，这个等待的时间叫存储转发时延\n在分组交换机接收完毕整个分组数据以后，肯定要继续传输到目标主机上，每个分组交换机上都连接了很多链路（主机），每条链路都有一个输出队列（output queue,也称输出缓存）\n假如某个分组需要传输到某个链路上的主机，而这条链路被另一个分组传输占用了，那么这个分组就必须在输出队列里排队等待,这个等待的时间叫排队时延(queuing delay)，类比收费站排队等待过关时浪费的时间。\n但是输出队列的缓存空间是有限的，如果他被撑爆了，将会出现数据丢失，这又被称为分组丢失（packet loss），俗语叫丢包\n收费站收钱，然后给卡的过程浪费的时间，叫传输时延（transmission delay），也就是分组交换机发出去那一瞬间浪费的时间，一般极短。\n传输出去以后，数据在路上跑，跑到下一个交换机之前，在路上浪费的时间叫传播时延（propagation delay）\n在整个过程中，端系统经过一个一个的路由器/交换机，最终到达目的端系统浪费的总时间叫端到端时延，也可以用第五节提供的跟踪工具可以看到三次握手分别浪费的时间，是不是很酷。\n一根100M带宽，如果全部跑满，他的峰值吞吐量（throughput）就是12Mbps,吞吐量就是单位时间内成功地传送数据的数量（以比特、字节、分组等测量）\n我们的家庭网络一般都是使用局域网（LAN）接入，其实也是带宽共享的一种。一般来说，整个小区是一个局域网，与电信骨干网相连接的带宽总出口如果有100M，也就是说，如果小区内有一百人同时在线，那么就是有一百人在共享这100M的带宽，因此，共享带宽下的宽带接入，在上网用户稍多时可能速度会有所降低。\n在宽带较不普及的小区，共享带宽会有很高的性价比，因为共享带宽比较便宜，又正好没人和你抢带宽；但如果在宽带较普及的小区，可以用ADSL（全称为 Asymmetric Digital Subscriber Line，非对称数字用户线路），每个用户的网络终端都有单独的一条线路与ADSL局域端相连，可以保证所有带宽是由每一用户独享的，即使用户激增，其速度也不会减慢。\n但是现在都到21世界20年代了，ADSL是用电话线上网，最大理论上行速率可达到 1Mbps，下行速率可达 8Mbps，早被淘汰了，老老实实用LAN，办大一点的宽带才是王道\n补充链接  对 IXP 的一些思考 \nICP 百度百科 \n阿里云说的多线 BGP 接入到底指的是什么东西？ \nBGP 维基百科 \nIDC 百度百科 \nSDN 与 IXP \n网络协议 百度百科 \n对等网络-百度百科 \n路由选择协议-百度百科 \n学习笔记-计算机网络 \n计算机网络（自顶向下方法）学习笔记 \n宽带中的 ADSL 与 LAN 有什么区别？ \n什么是共享带宽？ \n交换机和路由器有什么区别 \n为什么说交换机工作在数据链路层？ \n表示层（ presentation layer）和会话层（session layer）为什么会被弃用？ \n应用层、表示层、会话层、传输层、网络层、数据链路层、物理层 \nOSI 七层模型的学习-会话层、表示层和应用层 \n网络安全攻击分类分析 \n网络灵魂九问\n Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/linux/docker/",
	"title": "Docker",
	"tags": [],
	"description": "Docker",
	"content": " \r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/essay/",
	"title": "Essay",
	"tags": [],
	"description": "Article seek",
	"content": " July \r\r\r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/programing/go/github.com/gohugoio/hugo/",
	"title": "hugo",
	"tags": [],
	"description": "github.com/gohugoio/hugo",
	"content": " \rDescription\r\rHugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。 Hugo采用 Go 编程语言开发，Hugo 的设计目标是让创建网站重新变得有趣。\r\r\r\rShow More \rHugo 是一个通用的网站框架。从技术上讲，Hugo 是一个静态站点生成器。与动态构建页面的系统不同，Hugo 在创建或更新内容时构建页面。由于网站的浏览频率远高于编辑频率，因此 Hugo 旨在为您的网站最终用户提供最佳的浏览体验，并为网站作者提供理想的写作体验。\r使用 Hugo 构建的网站非常快速和安全。Hugo 构建的网站可以托管在任何地方，包括 Netlify、Heroku、GoDaddy、DreamHost、GitHub Pages、GitLab Pages、Surge、Aerobatic、Firebase、Google Cloud Storage、Amazon S3、Rackspace、Azure, 和 CloudFront，并且与 CDN 更配。Hugo 网站在运行时不需要数据库或依赖于诸如 Ruby、Python 或 PHP 等昂贵的运行时环境。\r我们认为 Hugo 是一个理想的网站创建工具，具有几乎即时的构建时间，能够在网站修改时即刻重建。\r\r\n1. Hugo 部署   二进制安装（推荐：简单、快速） 到 Hugo Releases 下载对应的操作系统版本的Hugo二进制文件（hugo或者hugo.exe）\n  编译部署 熟悉Go语言的朋友可以试下这个方法，不过great wall的存在让依赖不太好下载。不过下载下之后可以自己进行魔改。geek们可以试下。\ngo get -u -v github.com/spf13/hugo\n  开始建立hugo project hugo new site mydocs 建立好之后的目录结构为\n▸ archetypes/ ▸ content/ ▸ layouts/ ▸ static/ config.toml   刚创建好的hugo project还需设定主题模板之类的 到主题网站上面下载一个中意的模板，创建目录 themes，在 themes 目录里把皮肤 git clone 下来 Copy\r\r\r# 创建 themes 目录 $ cd themes $ git clone https://github.com/spf13/hyde.git \r\r\r  开始运行\nhugo server\r然后打开浏览器，输入http://localhost:1313就可以实时预览了\n  2. Ace document 配置方法 hugo new site docs cd docs cd themes git clone https://github.com/vantagedesign/ace-documentation 然后将themes\\ace-documentation\\exampleSite下面的三个文件夹拷贝到docs目录下面，覆盖掉原来的文件。 如果想自己开始创建文章的话，可以将content下面的文章清空，然后重新开始编写文章\n#接下来就可以生成静态站点了,在docs目录下输入 hugo #然后将生成的public文件夹发布到静态文章服务器就行了。 #文章后面会提供一个静态文章服务器的Go语言脚本，可以自己在虚拟机或者云服务器上先试下 3. 使用Github pages进行发布 在自己的GitHub仓库中新建一个仓库，Github提供了免费的静态页面托管服务，创建仓库的时候可以用github用户名.github.io创建，然后直接访问这个地址就可以访问自己的主页了。我们接下来就需要在public目录下面git clone这个仓库，然后把我们更新的内容推送上去，直接打开页面预览就可以了。\n$ cd public $ git init $ git remote add origin https://github.com/github用户名/GitHub用户名.github.io $ git add -A $ git commit -m \u0026#34;first commit\u0026#34; $ git push -u origin master 4.静态网站服务器 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;path/filepath\u0026#34; ) func main() { p, _ := filepath.Abs(filepath.Dir(\u0026#34;.\u0026#34;)) http.Handle(\u0026#34;/\u0026#34;, http.FileServer(http.Dir(p))) err := http.ListenAndServe(\u0026#34;:8088\u0026#34;, nil) if err != nil { fmt.Println(err) } }  这是个非常简易的脚本，不过用来显示我们之前做的静态网页是足够了。将public下面的所有文件拷入编译后的可执行文件目录下，执行这个可执行文件后，就可以去浏览效果了 下面会抽时间再补充一个自动同步文件的程序\n "
},
{
	"uri": "https://liuzeng01.github.io/programing/java/",
	"title": "Java",
	"tags": [],
	"description": "Java",
	"content": " \r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/linux/kernel/",
	"title": "Kernel",
	"tags": [],
	"description": "Kernel",
	"content": " \r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/booknote/",
	"title": "BookNote",
	"tags": [],
	"description": "Note",
	"content": " SRE \r\r\r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/programing/c/",
	"title": "C/C++",
	"tags": [],
	"description": "C/C++",
	"content": " \r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/programing/python/",
	"title": "python",
	"tags": [],
	"description": "python",
	"content": " \r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/programing/javascript/",
	"title": "JavaScript",
	"tags": [],
	"description": "JavaScript",
	"content": " \r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/linux/openstack/",
	"title": "OpenStack",
	"tags": [],
	"description": "OpenStack",
	"content": " \r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/programing/go/github.com/xujiajun/nutsdb/",
	"title": "nutsdb",
	"tags": [],
	"description": "nutsdb",
	"content": "  Description\r\rNutsDB是纯Go语言编写一个简单、高性能、内嵌型、持久化的key-value数据库。\nNutsDB支持事务，从v0.2.0之后的版本开始支持ACID的特性，建议使用最新的release版本。v0.2.0之前的版本，保持高性能，没有作sync，但是具备高性能的写（本地测试，百万数据写入达40~50W+/s）。所有的操作都在事务中执行。NutsDB从v0.2.0版本开始支持多种数据结构，如列表(list)、集合(set)、有序集合(sorted set)。从0.4.0版本开始增加自定义配置读写方式、启动时候的文件载入方式、sync是否开启等\n\r\r\rgithub.com/xujiajun/nutsdb  官方文档\n1. 安装 go get -u github.com/xujiajun/nutsdb 2. 使用 开启数据库 package main import ( \u0026#34;log\u0026#34; \u0026#34;github.com/xujiajun/nutsdb\u0026#34; ) func main() { opt := nutsdb.DefaultOptions opt.Dir = \u0026#34;/tmp/nutsdb\u0026#34; //这边数据库会自动创建这个目录文件 \tdb, err := nutsdb.Open(opt) if err != nil { log.Fatal(err) } defer db.Close() ... } 这里的默认配置是\nvar DefaultOptions = Options{ EntryIdxMode: HintKeyValAndRAMIdxMode, //EntryIdxMode 代表索引entry的模式. EntryIdxMode 包括选项: HintKeyValAndRAMIdxMode 、HintKeyAndRAMIdxMode和 HintBPTSparseIdxMode。其中HintKeyValAndRAMIdxMode 代表纯内存索引模式（key和value都会被cache）。 HintKeyAndRAMIdxMode 代表内存+磁盘的索引模式（只有key被cache）。 HintBPTSparseIdxMode（v0.4.0之后的版本支持） 是专门节约内存的设计方案，单机10亿条数据，只要80几M内存。但是读性能不高，需要自己加缓存来加速。 \tSegmentSize: defaultSegmentSize, NodeNum: 1, //代表节点的号码. \tRWMode: FileIO, //RWMode 代表读写模式. RWMode 包括两种选项: FileIO and MMap. FileIO 用标准的 I/O读写。 MMap 代表使用mmap进行读写 \tSyncEnable: true,//SyncEnable 代表调用了 Sync() 方法. 如果 SyncEnable 为 false， 写性能会很高，但是如果遇到断电或者系统奔溃，会有数据丢失的风险。 如果 SyncEnable 为 true，写性能会相比false的情况慢很多，但是数据更有保障，每次事务提交成功都会落盘 \tStartFileLoadingMode: MMap,//StartFileLoadingMode 代表启动数据库的载入文件的方式。参数选项同RWMode } 2. 使用方法 使用bucket buckets中文翻译过来是桶的意思，你可以理解成类似mysql的table表的概念，也可以理解成命名空间，或者多租户的概念。 所以你可以用他存不同的key的键值对，也可以存相同的key的键值对。所有的key在一个bucket里面不能重复。\nkey := []byte(\u0026#34;key001\u0026#34;) val := []byte(\u0026#34;val001\u0026#34;) bucket001 := \u0026#34;bucket001\u0026#34; if err := db.Update( func(tx *nutsdb.Tx) error { if err := tx.Put(bucket001, key, val, 0); err != nil { return err } return nil }); err != nil { log.Fatal(err) } bucket002 := \u0026#34;bucket002\u0026#34; if err := db.Update( func(tx *nutsdb.Tx) error { if err := tx.Put(bucket002, key, val, 0); err != nil { return err } return nil }); err != nil { log.Fatal(err) } 写入数据 if err := db.Update( func(tx *nutsdb.Tx) error { key := []byte(\u0026#34;name1\u0026#34;) val := []byte(\u0026#34;val1\u0026#34;) bucket := \u0026#34;bucket1\u0026#34; if err := tx.Put(bucket, key, val, 0); err != nil { return err } return nil }); err != nil { log.Fatal(err) } 读取数据 if err := db.View( func(tx *nutsdb.Tx) error { key := []byte(\u0026#34;name1\u0026#34;) bucket := \u0026#34;bucket1\u0026#34; if e, err := tx.Get(bucket, key); err != nil { return err } else { fmt.Println(string(e.Value)) // \u0026#34;val1-modify\u0026#34; \t} return nil }); err != nil { log.Println(err) } 删除数据 if err := db.Update( func(tx *nutsdb.Tx) error { key := []byte(\u0026#34;name1\u0026#34;) bucket := \u0026#34;bucket1\u0026#34; if err := tx.Delete(bucket, key); err != nil { return err } return nil }); err != nil { log.Fatal(err) } 更新数据 if err := db.Update( func(tx *nutsdb.Tx) error { key := []byte(\u0026#34;name1\u0026#34;) val := []byte(\u0026#34;val1-modify\u0026#34;) // 更新值 \tbucket := \u0026#34;bucket1\u0026#34; if err := tx.Put(bucket, key, val, 0); err != nil { return err } return nil }); err != nil { log.Fatal(err) } //仍然可以使用添加数据的方法 TTL时间设置 if err := db.Update( func(tx *nutsdb.Tx) error { key := []byte(\u0026#34;name1\u0026#34;) val := []byte(\u0026#34;val1\u0026#34;) bucket := \u0026#34;bucket1\u0026#34; // 如果设置 ttl = 0 or Persistent, 这个key就会永久不删除 \t// 这边 ttl = 60 , 60s之后就会过期。 \tif err := tx.Put(bucket, key, val, 60); err != nil { return err } return nil }); err != nil { log.Fatal(err) } 扫描key key在一个bucket里面按照byte-sorted有序排序的，所以对于keys的扫描操作，在NutsDB里是很高效的。\n前缀扫描  对于前缀的扫描，我们可以用PrefixScan 方法, 使用参数 offSet和limitNum 来限制返回的结果的数量，比方下面例子限制100个entries:  if err := db.View( func(tx *nutsdb.Tx) error { prefix := []byte(\u0026#34;user_\u0026#34;) bucket := \u0026#34;user_list\u0026#34; // 从offset=0开始 ，限制 100 entries 返回 \tif entries, err := tx.PrefixScan(bucket, prefix, 0, 100); err != nil { return err } else { for _, entry := range entries { fmt.Println(string(entry.Key), string(entry.Value)) } } return nil }); err != nil { log.Fatal(err) } 前缀后的正则扫描 对于前缀后的扫描，可以通过正则表达式对键的第二部分进行搜索来遍历一个键前缀，我们可以使用PrefixSearchScan方法，用参数reg来编写正则表达式，使用参数offsetNum、limitNum 来约束返回的条目的数量:\nif err := db.View( func(tx *nutsdb.Tx) error { prefix := []byte(\u0026#34;user_\u0026#34;) // 定义前缀 \treg := \u0026#34;99\u0026#34; // 定义正则表达式 \tbucket := \u0026#34;user_list\u0026#34; // 从offset=25开始，限制 100 entries 返回 \tif entries, _, err := tx.PrefixSearchScan(bucket, prefix, reg, 25, 100); err != nil { return err } else { for _, entry := range entries { fmt.Println(string(entry.Key), string(entry.Value)) } } return nil }); err != nil { log.Fatal(err) } 范围扫描 对于范围的扫描，我们可以用RangeScan方法。\nif err := db.View( func(tx *nutsdb.Tx) error { // 假设用户key从 user_0000000 to user_9999999. \t// 执行区间扫描类似这样一个start和end作为主要参数. \tstart := []byte(\u0026#34;user_0010001\u0026#34;) end := []byte(\u0026#34;user_0010010\u0026#34;) bucket := \u0026#34;user_list\u0026#34; if entries, err := tx.RangeScan(bucket, start, end); err != nil { return err } else { for _, entry := range entries { fmt.Println(string(entry.Key), string(entry.Value)) } } return nil }); err != nil { log.Fatal(err) } 读取全部数据 if err := db.View( func(tx *nutsdb.Tx) error { bucket := \u0026#34;user_list\u0026#34; entries, err := tx.GetAll(bucket) if err != nil { return err } for _, entry := range entries { fmt.Println(string(entry.Key),string(entry.Value)) } return nil }); err != nil { log.Println(err) 3. 补充概念 从v0.3.0版本起，NutsDB支持（A）原子性、C（一致性）、I（隔离性），并保证（D）持久化。以下参考wiki百科的对ACID定义分别讲一下。\n1、（A）原子性\n所谓原子性，一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。实现事务的原子性，要支持回滚操作，在某个操作失败后，回滚到事务执行之前的状态。一般的做法是类似数据快照的方案。关于这一点，NutsDB支持回滚操作。NutsDB的作法是先实际预演一边所有要执行的操作，这个时候数据其实还是uncommitted状态，一直到所有环节都没有问题，才会作commit操作，如果中间任何环节一旦发生错误，直接作rollback回滚操作，保证原子性。 就算发生错误的时候已经有数据进磁盘，下次启动也不会被索引到这些数据。\r 2、（C）一致性\n在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的数据必须完全符合预期的。NutsDB基于读写锁实现锁机制，在高并发场景下，一个读写事务具有排他性的，比如一个goroutine需要执行一个读写事务，其他不管想要读写的事务或者只读的只能等待，直到这个锁释放为止。保证了数据的一致性。所以这一点NutsDB满足一致性。\r 3、（I）隔离性\n数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。如上面的一致性所说，NutsDB基于读写锁实现锁机制。不会出现数据串的情况。所以也是满足隔离性的。\r关于事务的隔离级别，我们也来对照wiki百科，来看下NutsDB属于哪一个级别：\r隔离级别低到高：\r1）未提交读（READ UNCOMMITTED）\r这个是最低的隔离级别。允许“脏读”（dirty reads），事务可以看到其他事务“尚未提交”的修改。很明显nutsDB是避免脏读的。\r2）在提交读（READ COMMITTED）\r定义：这个隔离级别中，基于锁机制并发控制的DBMS需要对选定对象的写锁一直保持到事务结束，但是读锁在SELECT操作完成后马上释放（因此“不可重复读”现象可能会发生）。 看下“不可重复读”的定义：在一次事务中，当一行数据获取两遍得到不同的结果表示发生了“不可重复读”。\rnutsDB不会出现“不可重复读”这种情况，当高并发的时候，正在进行读写操作，一个goroutine刚好先拿到只读锁，这个时候要完成一个读写事务操作的那个goroutine要阻塞等到只读锁释放为止。也就避免上面的问题。\r3）在可重复读（REPEATABLE READS）\r定义：这个隔离级别中，基于锁机制并发控制的DBMS需要对选定对象的读锁（read locks）和写锁（write locks）一直保持到事务结束，但不要求“范围锁”，因此可能会发生“幻影读”。\r关于幻影读定义，指在事务执行过程中，当两个完全相同的查询语句执行得到不同的结果集。这种现象称为“幻影读（phantom read）”，有些人也叫他幻读，正如上面所说，在nutsDB中，当进行只读操作的时候，同一时间只能并发只读操作，其他有关“写”的事务是被阻塞的，直到这些只读锁释放为止，因此不会出现“幻影读”的情况。\r4）可串行化 （Serializable）\r定义：这个隔离级别是最高的。避免了所有上面的“脏读”、不可重复读”、“幻影读”现象。\r在nutsDB中，一个只读事务和一个写（读写）事务，是互斥的，需要串行执行，不会出现并发执行。nutsDB属于这个可串行化级别。 这个级别的隔离一般来说在高并发场景下性能会受到影响。但是如果锁本身性能还可以，也不失为一个简单有效的方法。当前版本nutsDB基于读写锁，在并发读多写少的场景下，性能会好一点。\r4、（D）持久化\r事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\r  Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/programing/",
	"title": "Programming",
	"tags": [],
	"description": "Programming",
	"content": " Go \r\rSQL \r\rJava \r\rC/C\u0026#43;\u0026#43; \r\rpython \r\rJavaScript \r\rFlutter \r\r\r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/programing/flutter/",
	"title": "Flutter",
	"tags": [],
	"description": "Flutter",
	"content": " \r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/programing/go/daily/golang%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/",
	"title": "Golang 数据结构",
	"tags": [],
	"description": "Daily Note",
	"content": " golang本质是全局按照值传递的，也就是copy值，那么你必须知道你的内存对象是包含哪些内容，才能清楚掌握你在copy值的时候复制了哪些东西  num bool string array slice map channel interface  package main func main () { var n int64 = 11 //n就是一个8字节的数据块。 var b bool = true //是一个1字节的数据块。  var s string = \u0026#34;test-string-1\u0026#34; //x  var a [3]bool = [3]bool{true, false, true} var sl []int = []int{1,2,3,4} var m map[int]string var c chan int var in interface{} _, _, _, _, _, _, _, _ = n, b, s, a, sl, m, c , in } string类型 (gdb) pt s type = struct string { uint8 *str; int len; } //string类型在go里是一个复合类型，s变量是一个16字节的变量。其中str字段指向字符串存储的地方 //s就是代表了一个16字节的数据块。所以我们每次定义一个string变量，除了字符序列，s的本身结构是分配16个字节在栈上。 数组类型 //数组类型，就是在地址空间中连续的一段内存块，和c一样（旁白：和c一样，都是平坦的内存结构）。 (gdb) p \u0026amp;a $13 = ([3]bool *) 0xc00003070d (gdb) x/6bx 0xc00003070d 0xc00003070d: 0x01 0x00 0x01 0x0b 0x00 0x00 切片类型 // 是个复合类型，变量本身是一个管理结构（和string一样），这个管理结构管理着一段连续的内存 (gdb) pt sl type = struct []int { int *array; int len; int cap; } map 类型 和 channel 类型 map类型和channel类型特别提一点，变量本身本质上是一个指针类型。也就是说上面我们定义了两个变量m，c，从内存分配的角度来讲，只在栈上分配了一个指针变量，并且这个指针还是nil值，所以我们经常看到 go 的一个特殊说明：slice，map，channel 这三种类型必须使用make来创建，就是这个道理。因为如果仅仅定义了类型变量，那仅仅是代表了分配了这个变量本身的内存空间，并且初始化是nil，一旦你直接用，那么就会导致非法地址引用的问题。slice 的24个字节的管理空间，map和channel的一个指针8个字节的空间。那么如果是调用了make，其实就会把下面的结构分配并初始化出来。\n(gdb) pt m type = struct hash\u0026lt;int, string\u0026gt; { int count; uint8 flags; uint8 B; uint16 noverflow; uint32 hash0; struct bucket\u0026lt;int, string\u0026gt; *buckets; struct bucket\u0026lt;int, string\u0026gt; *oldbuckets; uintptr nevacuate; struct runtime.mapextra *extra; } * (gdb) pt c type = struct hchan\u0026lt;int\u0026gt; { uint qcount; uint dataqsiz; void *buf; uint16 elemsize; uint32 closed; runtime._type *elemtype; uint sendx; uint recvx; struct waitq\u0026lt;int\u0026gt; recvq; struct waitq\u0026lt;int\u0026gt; sendq; runtime.mutex lock; }  Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/linux/kubernetes/",
	"title": "Kubernetes",
	"tags": [],
	"description": "Kubernetes",
	"content": " \r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/zsmart/",
	"title": "ZSmart",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://liuzeng01.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://liuzeng01.github.io/",
	"title": "My Document",
	"tags": [],
	"description": "",
	"content": " Linux \r\rEssay \r\rBookNote \r\rProgramming \r\rZSmart \r\r\r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]
