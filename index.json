[
{
	"uri": "https://liuzeng01.github.io/programing/go/",
	"title": "Go",
	"tags": [],
	"description": "Golang",
	"content": " Go Daily Note \r\rGo语言第三方库 \r\r\r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/programing/go/daily/",
	"title": "Go Daily Note",
	"tags": [],
	"description": "Daily Note",
	"content": " Json \r\rSort \r\rSSH \r\r文件操作 \r\r\r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/programing/go/github.com/",
	"title": "Go语言第三方库",
	"tags": [],
	"description": "GitHub上的Go开源库",
	"content": " routine \r\rhugo \r\rnutsdb \r\r\r "
},
{
	"uri": "https://liuzeng01.github.io/essay/july/hugo/",
	"title": "hugo语法",
	"tags": [],
	"description": "Essay",
	"content": " 1. hugo 2. Ace Document   button The button shortcode allows you to add a button to the page. This button is a HTML anchor element and can thus be used to link to another page or website.\n\rButton\r\rButton\r\rButton\r\rButton\r\rButton\r\rButton\r\rButton\r\rUsage Place the following shortcode on the page Copy\r\r\r{{\u0026lt; button style=\u0026#34;STYLE\u0026#34; link=\u0026#34;https://yourwebsite.com\u0026#34; \u0026gt;}} [content] {{\u0026lt; /button \u0026gt;}} \r\r\rParameters style The style parameter is directly applied to the alert as a class in the format \u0026ldquo;btn-{STYLE}\u0026quot;. Bootstrap comes with a variety of styles that can be used with this:\n primary secondary danger warning success info  Each style can also be presented as an \u0026lsquo;outline\u0026rsquo; variant by prefixing the style with \u0026lsquo;outline-\u0026rsquo;.\nExample: style=\u0026quot;outline-primary\u0026quot;.\nlink The link parameter may consist of an URL leading to a page or other website. Simply use it by defining a URL for the button to link to.\nExample: link=\u0026quot;https://google.com\u0026quot;.\n  Alert The alerts shortcode allows you to let information stand out by means of an alert styled box. This can be used to indicate danger, warning, success or info.\n\rI\u0026rsquo;m a danger alert\r\rI\u0026rsquo;m a warning alert\r\rI\u0026rsquo;m a success alert\r\rI\u0026rsquo;m an info alert\r\rUsage Place the following shortcode on the page Copy\r\r\r{{\u0026lt; alert style=\u0026#34;STYLE\u0026#34; \u0026gt;}} [content] {{\u0026lt; /alert \u0026gt;}} \r\r\rParameters Style  danger warning success info     Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/programing/go/daily/json/",
	"title": "Json ",
	"tags": [],
	"description": "Daily Note",
	"content": " Json   func Marshal(v interface{}) ([]byte, error) // json编码\n  func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error) // json编码带缩进\n  func Unmarshal(data []byte, v interface{}) error // json解码\n  package main import ( \u0026#34;fmt\u0026#34; // \u0026#34;reflect\u0026#34;  \u0026#34;encoding/json\u0026#34; ) type User struct{ // Name string `json:\u0026#34;-,\u0026#34;` // 这个导出才是 {\u0026#34;-\u0026#34;:\u0026#34;张三\u0026#34;,\u0026#34;age\u0026#34;:20}  // Name string `json:\u0026#34;-\u0026#34;` // always omitted  // Name string `json:\u0026#34;,omitempty\u0026#34;` // 如果为零值导出为空. 然而不想重命名.  Name string `json:\u0026#34;name,omitempty\u0026#34;` // 如果为零值导出为空.  // Age int `json:\u0026#34;age,string\u0026#34;` // 这个会把int变成json string...  // 上面那个很有用. 在 A map =\u0026gt; string =\u0026gt; B map 的时候可能会被弄成科学计数法..  // 用字符串表示时间戳这种可以避免这个...  Age int `json:\u0026#34;age\u0026#34;` sex int `json:\u0026#34;sex\u0026#34;` } func main() { u := User{\u0026#34;张三\u0026#34;, 20, 1} uu, _ := json.Marshal(u) // 只会导出公有的, 即首字母大写的  fmt.Println(string(uu)) }  Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/essay/july/",
	"title": "July",
	"tags": [],
	"description": "2020 07",
	"content": " hugo语法 \r\r\r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/linux/shell/",
	"title": "Shell",
	"tags": [],
	"description": "Shell",
	"content": " \r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/programing/go/daily/sort/",
	"title": "Sort",
	"tags": [],
	"description": "Daily Note",
	"content": " 实现Go提供的sort接口，来进行自定义排序  只需要实现下列三个接口，就可以进行排序\n package sort type Interface interface { Len() int // 获取元素数量  Less(i, j int) bool // i，j是序列元素的指数。  Swap(i, j int) // 交换元素 } 自己模拟了一个最简单的示例\npackage main\rimport (\r\u0026quot;fmt\u0026quot;\r\u0026quot;sort\u0026quot;\r)\rfunc main() {\rvar mysort MySort\rvar a SortType\ra.id = 5\ra.Name = \u0026quot;a\u0026quot;\rvar b SortType\rb.id = 51\rb.Name = \u0026quot;b\u0026quot;\rvar c SortType\rc.id = 6\rc.Name = \u0026quot;c\u0026quot;\rvar d SortType\rd.id = 1\rd.Name = \u0026quot;d\u0026quot;\rmysort = []SortType{a, b, c, d}\rsort.Sort(mysort)\rfmt.Println(mysort)\r}\rtype MySort []SortType\rtype SortType struct {\rName string\rid int\r}\rfunc (a MySort) Len() int { return len(a) }\rfunc (a MySort) Swap(i, j int) { a[i], a[j] = a[j], a[i] }\rfunc (a MySort) Less(i, j int) bool { return a[i].id \u0026lt; a[j].id }\r//输出结果为\r[{d 1} {a 5} {c 6} {b 51}]\r 接口实现不受限于结构体，任何类型都可以实现接口。但是系统自定义的类型是无法实现的，因为GO语言自己实现了这些[]int ,[]string 的接口。如果要自己实现自定义的排序的话，可以添加别名类型。\n  Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/booknote/sre/",
	"title": "SRE",
	"tags": [],
	"description": "SRE",
	"content": " SRE介绍 \r\r\r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/booknote/sre/sre%E4%BB%8B%E7%BB%8D/",
	"title": "SRE介绍",
	"tags": [],
	"description": "Note",
	"content": " \rSRE\r\rSRE是指Site Reliability Engineer (网站可靠性工程师)。他是软件工程师和系统管理员的结合，一个SRE工程师基本上需要掌握很多知识：算法，数据结构，编程能力，网络编程，分布式系统，可扩展架构，故障排除。\r\r\r\rSRE都干些什么？ SRE不是做底层硬件维护，而是负责各种服务的性能和稳定性。\r远离底层硬件，更多靠近软件基础架构层面，帮助企业客户打造强大的软件基础构架。\r\r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/programing/go/daily/ssh/",
	"title": "SSH",
	"tags": [],
	"description": "Daily Note",
	"content": " 利用Go语言提供的ssh包实现一个ssh工具 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;os\u0026#34; \u0026#34;time\u0026#34; \u0026#34;golang.org/x/crypto/ssh\u0026#34; ) func main() { session, err := connect(\u0026#34;root\u0026#34;, \u0026#34;abc@123A\u0026#34;, \u0026#34;10.45.11.115\u0026#34;, 22) if err != nil { log.Fatal(err) } defer session.Close() fmt.Printf(\u0026#34;----\u0026gt;\u0026#34;) session.Stdout = os.Stdout session.Stderr = os.Stderr session.Stdin = os.Stdin session.Run(\u0026#34;sh\u0026#34;) } func connect(user, password, host string, port int) (*ssh.Session, error) { var ( addr string clientConfig *ssh.ClientConfig client *ssh.Client session *ssh.Session err error ) clientConfig = \u0026amp;ssh.ClientConfig{ User: user, Auth: []ssh.AuthMethod{ ssh.Password(password), }, Timeout: 30 * time.Second, HostKeyCallback: func(hostname string, remote net.Addr, key ssh.PublicKey) error { return nil }, } // connet to ssh \taddr = fmt.Sprintf(\u0026#34;%s:%d\u0026#34;, host, port) if client, err = ssh.Dial(\u0026#34;tcp\u0026#34;, addr, clientConfig); err != nil { return nil, err } // create session \tif session, err = client.NewSession(); err != nil { return nil, err } return session, nil }  需要补充的：包装下os.Stdin接口，加入点显示什么的 ssh用来执行远程批量任务比较好。这个先写下来，回头实现下。 解决下windows下os.Stdin结束的行尾存在\u0026rsquo;\\r\\n\u0026rsquo;问题\n  Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/programing/go/daily/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/",
	"title": "文件操作",
	"tags": [],
	"description": "Note",
	"content": " 1.打开关闭文件 file open/close\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { // 只读方式打开当前目录下的main.go文件 \tfile, err := os.Open(\u0026#34;./main.go\u0026#34;) if err != nil { fmt.Println(\u0026#34;open file failed!, err:\u0026#34;, err) return } // 关闭文件 \tfile.Close() } 2.文件读取 file read 它接收一个字节切片，返回读取的字节数和可能的具体错误，读到文件末尾时会返回0和io.EOF\nfunc (f *File) Read(b []byte) (n int, err error) func main() { // 只读方式打开当前目录下的main.go文件 \tfile, err := os.Open(\u0026#34;./main.go\u0026#34;) if err != nil { fmt.Println(\u0026#34;open file failed!, err:\u0026#34;, err) return } defer file.Close() // 使用Read方法读取数据 \tvar tmp = make([]byte, 128) n, err := file.Read(tmp) if err == io.EOF { fmt.Println(\u0026#34;文件读完了\u0026#34;) return } if err != nil { fmt.Println(\u0026#34;read file failed, err:\u0026#34;, err) return } fmt.Printf(\u0026#34;读取了%d字节数据\\n\u0026#34;, n) fmt.Println(string(tmp[:n])) } 3.使用for循环读取文件中的所有数据。 func main() { // 只读方式打开当前目录下的main.go文件 \tfile, err := os.Open(\u0026#34;./main.go\u0026#34;) if err != nil { fmt.Println(\u0026#34;open file failed!, err:\u0026#34;, err) return } defer file.Close() // 循环读取文件 \tvar content []byte var tmp = make([]byte, 128) for { n, err := file.Read(tmp) if err == io.EOF { fmt.Println(\u0026#34;文件读完了\u0026#34;) break } if err != nil { fmt.Println(\u0026#34;read file failed, err:\u0026#34;, err) return } content = append(content, tmp[:n]...) } fmt.Println(string(content)) } 4.bufio  可以用来配合channel使用读取大文件\n package main import ( \u0026#34;bufio\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; ) // bufio按行读取示例 func main() { file, err := os.Open(\u0026#34;./xx.txt\u0026#34;) if err != nil { fmt.Println(\u0026#34;open file failed, err:\u0026#34;, err) return } defer file.Close() reader := bufio.NewReader(file) for { line, err := reader.ReadString(\u0026#39;\\n\u0026#39;) //注意是字符 \tif err == io.EOF { if len(line) != 0 { fmt.Println(line) } fmt.Println(\u0026#34;文件读完了\u0026#34;) break } if err != nil { fmt.Println(\u0026#34;read file failed, err:\u0026#34;, err) return } fmt.Print(line) } } 5.ioutil 读取整个文件 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; ) // ioutil.ReadFile读取整个文件 func main() { content, err := ioutil.ReadFile(\u0026#34;./main.go\u0026#34;) if err != nil { fmt.Println(\u0026#34;read file failed, err:\u0026#34;, err) return } fmt.Println(string(content)) } 6.文件写入操作  os.OpenFile()函数能够以指定模式打开文件，从而实现文件写入相关功能。 func OpenFile(name string, flag int, perm FileMode) (*File, error) {\r...\r}\n name：要打开的文件名 flag：打开文件的模式。 模式有以下几种：\n    模式 含义      os.O_WRONLY 只写    os.O_CREATE 创建文件    os.O_RDONLY 只读    os.O_RDWR 读写    os.O_TRUNC 清空    os.O_APPEND 追加      perm：文件权限，一个八进制数。r（读）04，w（写）02，x（执行）01。\n 7.Write和WriteString func main() { file, err := os.OpenFile(\u0026#34;xx.txt\u0026#34;, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666) if err != nil { fmt.Println(\u0026#34;open file failed, err:\u0026#34;, err) return } defer file.Close() str := \u0026#34;hello 沙河\u0026#34; file.Write([]byte(str)) //写入字节切片数据 \tfile.WriteString(\u0026#34;hello 小王子\u0026#34;) //直接写入字符串数据 }  bufio.NewWriter\n func main() { file, err := os.OpenFile(\u0026#34;xx.txt\u0026#34;, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666) if err != nil { fmt.Println(\u0026#34;open file failed, err:\u0026#34;, err) return } defer file.Close() writer := bufio.NewWriter(file) for i := 0; i \u0026lt; 10; i++ { writer.WriteString(\u0026#34;hello沙河\\n\u0026#34;) //将数据先写入缓存 \t} writer.Flush() //将缓存中的内容写入文件 }  ioutil.WriteFile\n func main() { str := \u0026#34;hello 沙河\u0026#34; err := ioutil.WriteFile(\u0026#34;./xx.txt\u0026#34;, []byte(str), 0666) if err != nil { fmt.Println(\u0026#34;write file failed, err:\u0026#34;, err) return } } 8.copyFile 借助io.Copy()实现一个拷贝文件函数。\n// CopyFile 拷贝文件函数 func CopyFile(dstName, srcName string) (written int64, err error) { // 以读方式打开源文件 \tsrc, err := os.Open(srcName) if err != nil { fmt.Printf(\u0026#34;open %s failed, err:%v.\\n\u0026#34;, srcName, err) return } defer src.Close() // 以写|创建的方式打开目标文件 \tdst, err := os.OpenFile(dstName, os.O_WRONLY|os.O_CREATE, 0644) if err != nil { fmt.Printf(\u0026#34;open %s failed, err:%v.\\n\u0026#34;, dstName, err) return } defer dst.Close() return io.Copy(dst, src) //调用io.Copy()拷贝内容 } func main() { _, err := CopyFile(\u0026#34;dst.txt\u0026#34;, \u0026#34;src.txt\u0026#34;) if err != nil { fmt.Println(\u0026#34;copy file failed, err:\u0026#34;, err) return } fmt.Println(\u0026#34;copy done!\u0026#34;) }  实现一个cat命令 使用文件操作相关知识，模拟实现linux平台cat命令的功能。\n package main import ( \u0026#34;bufio\u0026#34; \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; ) // cat命令实现 func cat(r *bufio.Reader) { for { buf, err := r.ReadBytes(\u0026#39;\\n\u0026#39;) //注意是字符 \tif err == io.EOF { break } fmt.Fprintf(os.Stdout, \u0026#34;%s\u0026#34;, buf) } } func main() { flag.Parse() // 解析命令行参数 \tif flag.NArg() == 0 { // 如果没有参数默认从标准输入读取内容 \tcat(bufio.NewReader(os.Stdin)) } // 依次读取每个指定文件的内容并打印到终端 \tfor i := 0; i \u0026lt; flag.NArg(); i++ { f, err := os.Open(flag.Arg(i)) if err != nil { fmt.Fprintf(os.Stdout, \u0026#34;reading from %s failed, err:%v\\n\u0026#34;, flag.Arg(i), err) continue } cat(bufio.NewReader(f)) } }  Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/linux/",
	"title": "Linux",
	"tags": [],
	"description": "Linux Daily",
	"content": " Shell \r\rRedis \r\rDocker \r\rKernel \r\rOpenStack \r\rKubernetes \r\r\r"
},
{
	"uri": "https://liuzeng01.github.io/linux/redis/",
	"title": "Redis",
	"tags": [],
	"description": "Redis",
	"content": " \r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/programing/go/github.com/x-mod/routine/",
	"title": "routine",
	"tags": [],
	"description": "github.com/x-mod/routine",
	"content": "github.com/x-mod/routine  为什么要写这么一个基础库呢？\n  每段程序都是从 main 函数开始的，但是，却不会将整个程序的功能实现都放在 main 函数里。而是，通过层层功能的抽象与封装，最终，在 main 函数仅提供功能函数的入口。所以，当我们看很多大型程序时，其实，main 函数是非常简单的。\n  但是，即使 main 函数越变越简单，有些必要的功能则是逃不掉的。例如程序启动参数、程序的信号处理，这些通常还是会放在 main 函数进行处理。\n  除了以上 main 函数本身的处理以外，我发现将程序中的执行绪，也就是固定的 Go 协程的入口放在 main 函数中进行定义，可以帮助维护者更加快速的理解应用的逻辑实现。\n link 使用方法 import \u0026#34;github.com/x-mod/routine\u0026#34; //timeout timeout := routine.Timeout(time.Minute, exec) //retry retry := routine.Retry(3, exec) //repeat repeat := routine.Repeat(10, time.Second, exec) //concurrent concurrent := routine.Concurrent(4, exec) //schedule executor crontab := routine.Crontab(\u0026#34;* * * * *\u0026#34;, exec) //command command := routine.Command(\u0026#34;echo\u0026#34;, routine.ARG(\u0026#34;hello routine!\u0026#34;)) //parallel parallel := routine.Parallel(exec1, exec2, exec3, ...) //sequence sequece := routine.Append(exec1, exec2, exec3, ...)  github上提供的示例程序\n package main import ( \u0026#34;context\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;syscall\u0026#34; \u0026#34;time\u0026#34; _ \u0026#34;net/http/pprof\u0026#34; \u0026#34;runtime/trace\u0026#34; \u0026#34;github.com/x-mod/routine\u0026#34; ) func prepare(ctx context.Context) error { log.Println(\u0026#34;prepare begin\u0026#34;) defer log.Println(\u0026#34;prepare end\u0026#34;) trace.Logf(ctx, \u0026#34;prepare\u0026#34;, \u0026#34;prepare ... ok\u0026#34;) return nil } func cleanup(ctx context.Context) error { log.Println(\u0026#34;cleanup begin\u0026#34;) defer log.Println(\u0026#34;cleanup end\u0026#34;) time.Sleep(time.Millisecond * 50) trace.Logf(ctx, \u0026#34;cleanup\u0026#34;, \u0026#34;cleanup ... ok\u0026#34;) return nil } func foo(ctx context.Context) error { log.Println(\u0026#34;foo begin\u0026#34;) defer log.Println(\u0026#34;foo end\u0026#34;) time.Sleep(time.Second * 2) trace.Logf(ctx, \u0026#34;foo\u0026#34;, \u0026#34;sleeping 2s done\u0026#34;) return nil } func bar(ctx context.Context) error { log.Println(\u0026#34;bar begin\u0026#34;) defer log.Println(\u0026#34;bar end\u0026#34;) for i := 0; i \u0026lt; 10; i++ { log.Println(i) trace.Logf(ctx, \u0026#34;bar\u0026#34;, \u0026#34;counting ... %d\u0026#34;, i) } return nil } func main() { f, err := os.Create(\u0026#34;trace.out\u0026#34;) if err != nil { log.Fatalf(\u0026#34;failed to create trace output file: %v\u0026#34;, err) } defer func() { if err := f.Close(); err != nil { log.Fatalf(\u0026#34;failed to close trace file: %v\u0026#34;, err) } }() if err := routine.Main( context.TODO(), routine.ExecutorFunc(bar), routine.Signal(syscall.SIGINT, routine.SigHandler(func() { os.Exit(1) })), routine.Prepare(routine.ExecutorFunc(prepare)), routine.Cleanup(routine.ExecutorFunc(cleanup)), routine.Trace(f), routine.Go(routine.ExecutorFunc(foo)), routine.Go(routine.ExecutorFunc(foo)), routine.Go(routine.ExecutorFunc(foo)), ); err != nil { log.Println(err) } }  接下来是自己的一些模仿实现\n package main import ( \u0026#34;context\u0026#34; \u0026#34;time\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/x-mod/routine\u0026#34; ) func main() { err := routine.Main( context.TODO(), routine.ExecutorFunc(bar), //main协程入口 \troutine.Prepare(routine.ExecutorFunc(prepare)), //启动开始前的准备函数 \troutine.Cleanup(routine.ExecutorFunc(exitclean)), //启动关闭后的清理函数 \troutine.Go(routine.ExecutorFunc(dosomething)), //启动并发的协程 \troutine.Go(routine.Concurrent(5, routine.ExecutorFunc(conexec))), //启动并发执行同一程序 \t//routine.Go(routine.Crontab(\u0026#34;*/1 * * * *\u0026#34;, routine.ExecutorFunc(crontabexec))), //定时执行任务，配置crontab表达式 \troutine.Go(routine.Repeat(3, time.Second, routine.ExecutorFunc(repeatexec))), //定时重复执行一项程序 \t//routine.Go(routine.Deadline(time.Now().Add(5*time.Second), routine.ExecutorFunc(deadlinexec))),这个没搞明白 \t) if err != nil { fmt.Println(err) } } func bar(ctx context.Context) error { fmt.Println(\u0026#34;bar begin\u0026#34;) fmt.Println(time.Now()) defer fmt.Println(\u0026#34;bar end\u0026#34;) return nil } func prepare(ctx context.Context) error { fmt.Println(\u0026#34;Start Prepare !!\u0026#34;) defer fmt.Println(\u0026#34;Prepare finish !!\u0026#34;) return nil } func exitclean(ctx context.Context) error { fmt.Println(\u0026#34;Exiting !!\u0026#34;) defer fmt.Println(\u0026#34;Exited\u0026#34;) return nil } func dosomething(ctx context.Context) error { routine.New(routine.ExecutorFunc(bar)).Execute(ctx) //启动新的协程 \ttime.Sleep(50 * time.Millisecond) fmt.Println(time.Now()) return nil } func conexec(ctx context.Context) error { fmt.Println(\u0026#34;并发执行中！！！\u0026#34;) return nil } func crontabexec(ctx context.Context) error { fmt.Println(\u0026#34;定时执行中 ~~~\u0026#34;) return nil } func repeatexec(ctx context.Context) error { fmt.Println(\u0026#34;重复执行中，每隔一秒执行一次\u0026#34;) return nil } func deadlinexec(ctx context.Context) error { for i := 0; i \u0026lt; 10; i++ { fmt.Printf(\u0026#34;等待deadline。。。,%d 秒\\n\u0026#34;, i) time.Sleep(time.Second) } return nil }   image title   总结  这个库包装了所有常见的需要goroutine操作的情景，可以支持并发，串行，重复执行，重试，定时执行，启动新协程等一系列常用的Go并发场景，以后多包装使用这个库，能剩下不少的事情   \u0026ndash;\n"
},
{
	"uri": "https://liuzeng01.github.io/programing/sql/",
	"title": "SQL",
	"tags": [],
	"description": "SQL",
	"content": " \r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/linux/docker/",
	"title": "Docker",
	"tags": [],
	"description": "Docker",
	"content": " \r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/essay/",
	"title": "Essay",
	"tags": [],
	"description": "Article seek",
	"content": " July \r\r\r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/programing/go/github.com/gohugoio/hugo/",
	"title": "hugo",
	"tags": [],
	"description": "github.com/gohugoio/hugo",
	"content": " \rDescription\r\rHugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。 Hugo采用 Go 编程语言开发，Hugo 的设计目标是让创建网站重新变得有趣。\r\r\r\rShow More \rHugo 是一个通用的网站框架。从技术上讲，Hugo 是一个静态站点生成器。与动态构建页面的系统不同，Hugo 在创建或更新内容时构建页面。由于网站的浏览频率远高于编辑频率，因此 Hugo 旨在为您的网站最终用户提供最佳的浏览体验，并为网站作者提供理想的写作体验。\r使用 Hugo 构建的网站非常快速和安全。Hugo 构建的网站可以托管在任何地方，包括 Netlify、Heroku、GoDaddy、DreamHost、GitHub Pages、GitLab Pages、Surge、Aerobatic、Firebase、Google Cloud Storage、Amazon S3、Rackspace、Azure, 和 CloudFront，并且与 CDN 更配。Hugo 网站在运行时不需要数据库或依赖于诸如 Ruby、Python 或 PHP 等昂贵的运行时环境。\r我们认为 Hugo 是一个理想的网站创建工具，具有几乎即时的构建时间，能够在网站修改时即刻重建。\r\r\n1. Hugo 部署   二进制安装（推荐：简单、快速） 到 Hugo Releases 下载对应的操作系统版本的Hugo二进制文件（hugo或者hugo.exe）\n  编译部署 熟悉Go语言的朋友可以试下这个方法，不过great wall的存在让依赖不太好下载。不过下载下之后可以自己进行魔改。geek们可以试下。\ngo get -u -v github.com/spf13/hugo\n  开始建立hugo project hugo new site mydocs 建立好之后的目录结构为\n▸ archetypes/ ▸ content/ ▸ layouts/ ▸ static/ config.toml   刚创建好的hugo project还需设定主题模板之类的 到主题网站上面下载一个中意的模板，创建目录 themes，在 themes 目录里把皮肤 git clone 下来 Copy\r\r\r# 创建 themes 目录 $ cd themes $ git clone https://github.com/spf13/hyde.git \r\r\r  开始运行\nhugo server\r然后打开浏览器，输入http://localhost:1313就可以实时预览了\n  2. Ace document 配置方法 hugo new site docs cd docs cd themes git clone https://github.com/vantagedesign/ace-documentation 然后将themes\\ace-documentation\\exampleSite下面的三个文件夹拷贝到docs目录下面，覆盖掉原来的文件。 如果想自己开始创建文章的话，可以将content下面的文章清空，然后重新开始编写文章\n#接下来就可以生成静态站点了,在docs目录下输入 hugo #然后将生成的public文件夹发布到静态文章服务器就行了。 #文章后面会提供一个静态文章服务器的Go语言脚本，可以自己在虚拟机或者云服务器上先试下 3. 使用Github pages进行发布 在自己的GitHub仓库中新建一个仓库，Github提供了免费的静态页面托管服务，创建仓库的时候可以用github用户名.github.io创建，然后直接访问这个地址就可以访问自己的主页了。我们接下来就需要在public目录下面git clone这个仓库，然后把我们更新的内容推送上去，直接打开页面预览就可以了。\n$ cd public $ git init $ git remote add origin https://github.com/github用户名/GitHub用户名.github.io $ git add -A $ git commit -m \u0026#34;first commit\u0026#34; $ git push -u origin master 4.静态网站服务器 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;path/filepath\u0026#34; ) func main() { p, _ := filepath.Abs(filepath.Dir(\u0026#34;.\u0026#34;)) http.Handle(\u0026#34;/\u0026#34;, http.FileServer(http.Dir(p))) err := http.ListenAndServe(\u0026#34;:8088\u0026#34;, nil) if err != nil { fmt.Println(err) } }  这是个非常简易的脚本，不过用来显示我们之前做的静态网页是足够了。将public下面的所有文件拷入编译后的可执行文件目录下，执行这个可执行文件后，就可以去浏览效果了 下面会抽时间再补充一个自动同步文件的程序\n "
},
{
	"uri": "https://liuzeng01.github.io/programing/java/",
	"title": "Java",
	"tags": [],
	"description": "Java",
	"content": " \r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/linux/kernel/",
	"title": "Kernel",
	"tags": [],
	"description": "Kernel",
	"content": " \r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/booknote/",
	"title": "BookNote",
	"tags": [],
	"description": "Note",
	"content": " SRE \r\r\r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/programing/c/",
	"title": "C/C++",
	"tags": [],
	"description": "C/C++",
	"content": " \r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/programing/python/",
	"title": "python",
	"tags": [],
	"description": "python",
	"content": " \r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/programing/javascript/",
	"title": "JavaScript",
	"tags": [],
	"description": "JavaScript",
	"content": " \r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/linux/openstack/",
	"title": "OpenStack",
	"tags": [],
	"description": "OpenStack",
	"content": " \r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/programing/go/github.com/xujiajun/nutsdb/",
	"title": "nutsdb",
	"tags": [],
	"description": "nutsdb",
	"content": "  Description\r\rNutsDB是纯Go语言编写一个简单、高性能、内嵌型、持久化的key-value数据库。\nNutsDB支持事务，从v0.2.0之后的版本开始支持ACID的特性，建议使用最新的release版本。v0.2.0之前的版本，保持高性能，没有作sync，但是具备高性能的写（本地测试，百万数据写入达40~50W+/s）。所有的操作都在事务中执行。NutsDB从v0.2.0版本开始支持多种数据结构，如列表(list)、集合(set)、有序集合(sorted set)。从0.4.0版本开始增加自定义配置读写方式、启动时候的文件载入方式、sync是否开启等\n\r\r\rgithub.com/xujiajun/nutsdb  官方文档\n1. 安装 go get -u github.com/xujiajun/nutsdb 2. 使用 开启数据库 package main import ( \u0026#34;log\u0026#34; \u0026#34;github.com/xujiajun/nutsdb\u0026#34; ) func main() { opt := nutsdb.DefaultOptions opt.Dir = \u0026#34;/tmp/nutsdb\u0026#34; //这边数据库会自动创建这个目录文件 \tdb, err := nutsdb.Open(opt) if err != nil { log.Fatal(err) } defer db.Close() ... } 这里的默认配置是\nvar DefaultOptions = Options{ EntryIdxMode: HintKeyValAndRAMIdxMode, //EntryIdxMode 代表索引entry的模式. EntryIdxMode 包括选项: HintKeyValAndRAMIdxMode 、HintKeyAndRAMIdxMode和 HintBPTSparseIdxMode。其中HintKeyValAndRAMIdxMode 代表纯内存索引模式（key和value都会被cache）。 HintKeyAndRAMIdxMode 代表内存+磁盘的索引模式（只有key被cache）。 HintBPTSparseIdxMode（v0.4.0之后的版本支持） 是专门节约内存的设计方案，单机10亿条数据，只要80几M内存。但是读性能不高，需要自己加缓存来加速。 \tSegmentSize: defaultSegmentSize, NodeNum: 1, //代表节点的号码. \tRWMode: FileIO, //RWMode 代表读写模式. RWMode 包括两种选项: FileIO and MMap. FileIO 用标准的 I/O读写。 MMap 代表使用mmap进行读写 \tSyncEnable: true,//SyncEnable 代表调用了 Sync() 方法. 如果 SyncEnable 为 false， 写性能会很高，但是如果遇到断电或者系统奔溃，会有数据丢失的风险。 如果 SyncEnable 为 true，写性能会相比false的情况慢很多，但是数据更有保障，每次事务提交成功都会落盘 \tStartFileLoadingMode: MMap,//StartFileLoadingMode 代表启动数据库的载入文件的方式。参数选项同RWMode } 2. 使用方法 使用bucket buckets中文翻译过来是桶的意思，你可以理解成类似mysql的table表的概念，也可以理解成命名空间，或者多租户的概念。 所以你可以用他存不同的key的键值对，也可以存相同的key的键值对。所有的key在一个bucket里面不能重复。\nkey := []byte(\u0026#34;key001\u0026#34;) val := []byte(\u0026#34;val001\u0026#34;) bucket001 := \u0026#34;bucket001\u0026#34; if err := db.Update( func(tx *nutsdb.Tx) error { if err := tx.Put(bucket001, key, val, 0); err != nil { return err } return nil }); err != nil { log.Fatal(err) } bucket002 := \u0026#34;bucket002\u0026#34; if err := db.Update( func(tx *nutsdb.Tx) error { if err := tx.Put(bucket002, key, val, 0); err != nil { return err } return nil }); err != nil { log.Fatal(err) } 写入数据 if err := db.Update( func(tx *nutsdb.Tx) error { key := []byte(\u0026#34;name1\u0026#34;) val := []byte(\u0026#34;val1\u0026#34;) bucket := \u0026#34;bucket1\u0026#34; if err := tx.Put(bucket, key, val, 0); err != nil { return err } return nil }); err != nil { log.Fatal(err) } 读取数据 if err := db.View( func(tx *nutsdb.Tx) error { key := []byte(\u0026#34;name1\u0026#34;) bucket := \u0026#34;bucket1\u0026#34; if e, err := tx.Get(bucket, key); err != nil { return err } else { fmt.Println(string(e.Value)) // \u0026#34;val1-modify\u0026#34; \t} return nil }); err != nil { log.Println(err) } 删除数据 if err := db.Update( func(tx *nutsdb.Tx) error { key := []byte(\u0026#34;name1\u0026#34;) bucket := \u0026#34;bucket1\u0026#34; if err := tx.Delete(bucket, key); err != nil { return err } return nil }); err != nil { log.Fatal(err) } 更新数据 if err := db.Update( func(tx *nutsdb.Tx) error { key := []byte(\u0026#34;name1\u0026#34;) val := []byte(\u0026#34;val1-modify\u0026#34;) // 更新值 \tbucket := \u0026#34;bucket1\u0026#34; if err := tx.Put(bucket, key, val, 0); err != nil { return err } return nil }); err != nil { log.Fatal(err) } //仍然可以使用添加数据的方法 TTL时间设置 if err := db.Update( func(tx *nutsdb.Tx) error { key := []byte(\u0026#34;name1\u0026#34;) val := []byte(\u0026#34;val1\u0026#34;) bucket := \u0026#34;bucket1\u0026#34; // 如果设置 ttl = 0 or Persistent, 这个key就会永久不删除 \t// 这边 ttl = 60 , 60s之后就会过期。 \tif err := tx.Put(bucket, key, val, 60); err != nil { return err } return nil }); err != nil { log.Fatal(err) } 扫描key key在一个bucket里面按照byte-sorted有序排序的，所以对于keys的扫描操作，在NutsDB里是很高效的。\n前缀扫描  对于前缀的扫描，我们可以用PrefixScan 方法, 使用参数 offSet和limitNum 来限制返回的结果的数量，比方下面例子限制100个entries:  if err := db.View( func(tx *nutsdb.Tx) error { prefix := []byte(\u0026#34;user_\u0026#34;) bucket := \u0026#34;user_list\u0026#34; // 从offset=0开始 ，限制 100 entries 返回 \tif entries, err := tx.PrefixScan(bucket, prefix, 0, 100); err != nil { return err } else { for _, entry := range entries { fmt.Println(string(entry.Key), string(entry.Value)) } } return nil }); err != nil { log.Fatal(err) } 前缀后的正则扫描 对于前缀后的扫描，可以通过正则表达式对键的第二部分进行搜索来遍历一个键前缀，我们可以使用PrefixSearchScan方法，用参数reg来编写正则表达式，使用参数offsetNum、limitNum 来约束返回的条目的数量:\nif err := db.View( func(tx *nutsdb.Tx) error { prefix := []byte(\u0026#34;user_\u0026#34;) // 定义前缀 \treg := \u0026#34;99\u0026#34; // 定义正则表达式 \tbucket := \u0026#34;user_list\u0026#34; // 从offset=25开始，限制 100 entries 返回 \tif entries, _, err := tx.PrefixSearchScan(bucket, prefix, reg, 25, 100); err != nil { return err } else { for _, entry := range entries { fmt.Println(string(entry.Key), string(entry.Value)) } } return nil }); err != nil { log.Fatal(err) } 范围扫描 对于范围的扫描，我们可以用RangeScan方法。\nif err := db.View( func(tx *nutsdb.Tx) error { // 假设用户key从 user_0000000 to user_9999999. \t// 执行区间扫描类似这样一个start和end作为主要参数. \tstart := []byte(\u0026#34;user_0010001\u0026#34;) end := []byte(\u0026#34;user_0010010\u0026#34;) bucket := \u0026#34;user_list\u0026#34; if entries, err := tx.RangeScan(bucket, start, end); err != nil { return err } else { for _, entry := range entries { fmt.Println(string(entry.Key), string(entry.Value)) } } return nil }); err != nil { log.Fatal(err) } 读取全部数据 if err := db.View( func(tx *nutsdb.Tx) error { bucket := \u0026#34;user_list\u0026#34; entries, err := tx.GetAll(bucket) if err != nil { return err } for _, entry := range entries { fmt.Println(string(entry.Key),string(entry.Value)) } return nil }); err != nil { log.Println(err) 3. 补充概念 从v0.3.0版本起，NutsDB支持（A）原子性、C（一致性）、I（隔离性），并保证（D）持久化。以下参考wiki百科的对ACID定义分别讲一下。\n1、（A）原子性\n所谓原子性，一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。实现事务的原子性，要支持回滚操作，在某个操作失败后，回滚到事务执行之前的状态。一般的做法是类似数据快照的方案。关于这一点，NutsDB支持回滚操作。NutsDB的作法是先实际预演一边所有要执行的操作，这个时候数据其实还是uncommitted状态，一直到所有环节都没有问题，才会作commit操作，如果中间任何环节一旦发生错误，直接作rollback回滚操作，保证原子性。 就算发生错误的时候已经有数据进磁盘，下次启动也不会被索引到这些数据。\r 2、（C）一致性\n在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的数据必须完全符合预期的。NutsDB基于读写锁实现锁机制，在高并发场景下，一个读写事务具有排他性的，比如一个goroutine需要执行一个读写事务，其他不管想要读写的事务或者只读的只能等待，直到这个锁释放为止。保证了数据的一致性。所以这一点NutsDB满足一致性。\r 3、（I）隔离性\n数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。如上面的一致性所说，NutsDB基于读写锁实现锁机制。不会出现数据串的情况。所以也是满足隔离性的。\r关于事务的隔离级别，我们也来对照wiki百科，来看下NutsDB属于哪一个级别：\r隔离级别低到高：\r1）未提交读（READ UNCOMMITTED）\r这个是最低的隔离级别。允许“脏读”（dirty reads），事务可以看到其他事务“尚未提交”的修改。很明显nutsDB是避免脏读的。\r2）在提交读（READ COMMITTED）\r定义：这个隔离级别中，基于锁机制并发控制的DBMS需要对选定对象的写锁一直保持到事务结束，但是读锁在SELECT操作完成后马上释放（因此“不可重复读”现象可能会发生）。 看下“不可重复读”的定义：在一次事务中，当一行数据获取两遍得到不同的结果表示发生了“不可重复读”。\rnutsDB不会出现“不可重复读”这种情况，当高并发的时候，正在进行读写操作，一个goroutine刚好先拿到只读锁，这个时候要完成一个读写事务操作的那个goroutine要阻塞等到只读锁释放为止。也就避免上面的问题。\r3）在可重复读（REPEATABLE READS）\r定义：这个隔离级别中，基于锁机制并发控制的DBMS需要对选定对象的读锁（read locks）和写锁（write locks）一直保持到事务结束，但不要求“范围锁”，因此可能会发生“幻影读”。\r关于幻影读定义，指在事务执行过程中，当两个完全相同的查询语句执行得到不同的结果集。这种现象称为“幻影读（phantom read）”，有些人也叫他幻读，正如上面所说，在nutsDB中，当进行只读操作的时候，同一时间只能并发只读操作，其他有关“写”的事务是被阻塞的，直到这些只读锁释放为止，因此不会出现“幻影读”的情况。\r4）可串行化 （Serializable）\r定义：这个隔离级别是最高的。避免了所有上面的“脏读”、不可重复读”、“幻影读”现象。\r在nutsDB中，一个只读事务和一个写（读写）事务，是互斥的，需要串行执行，不会出现并发执行。nutsDB属于这个可串行化级别。 这个级别的隔离一般来说在高并发场景下性能会受到影响。但是如果锁本身性能还可以，也不失为一个简单有效的方法。当前版本nutsDB基于读写锁，在并发读多写少的场景下，性能会好一点。\r4、（D）持久化\r事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\r  Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/programing/",
	"title": "Programming",
	"tags": [],
	"description": "Programming",
	"content": " Go \r\rSQL \r\rJava \r\rC/C\u0026#43;\u0026#43; \r\rpython \r\rJavaScript \r\rFlutter \r\r\r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/programing/flutter/",
	"title": "Flutter",
	"tags": [],
	"description": "Flutter",
	"content": " \r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/linux/kubernetes/",
	"title": "Kubernetes",
	"tags": [],
	"description": "Kubernetes",
	"content": " \r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/zsmart/",
	"title": "ZSmart",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://liuzeng01.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://liuzeng01.github.io/",
	"title": "My Document",
	"tags": [],
	"description": "",
	"content": " Linux \r\rEssay \r\rBookNote \r\rProgramming \r\rZSmart \r\r\r Back\r\r"
},
{
	"uri": "https://liuzeng01.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]
